<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LI SIR</title>
  
  <subtitle>Remember me.</subtitle>
  <link href="https://lisir.me/hexo-theme-keep/atom.xml" rel="self"/>
  
  <link href="https://lisir.me/hexo-theme-keep/"/>
  <updated>2024-09-28T07:18:48.000Z</updated>
  <id>https://lisir.me/hexo-theme-keep/</id>
  
  <author>
    <name>LI SIR</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>使用ACME申请证书（证书自动续期）</title>
    <link href="https://lisir.me/hexo-theme-keep/posts/c44653d8/"/>
    <id>https://lisir.me/hexo-theme-keep/posts/c44653d8/</id>
    <published>2024-09-28T05:44:35.000Z</published>
    <updated>2024-09-28T07:18:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>网站想要升级到HTTPS，首先得申请下发个安全证书，现在下发证书很简单，方式也很多，很多域名提供商都提供免费证书申请。但是，很多证书都是有时间限制（3个月或者1年），时间到期就需要手动重新，手续麻烦而且还会忘记续期，如果想一劳永逸可以用工具自动生成证书并且自动续租。续租工具和方式也很多，本文将讲解用 ACME 实现证书申请和证书自动续期。</p><span id="more"></span><hr><h2 id="安装-ACME"><a href="#安装-ACME" class="headerlink" title="安装 ACME"></a>安装 ACME</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apt install socat</span><br><span class="line">curl  https://get.acme.sh | sh</span><br></pre></td></tr></table></figure><p>安装程序会自动做以下操作：</p><ul><li>自动把 acme.sh 安装到你的 <strong>home</strong> 的<code>.acme.sh</code>目录下，即<code>~/.acme.sh/</code></li><li>自动创建一个 bash 的 alias，方便你的使用: <code>alias acme.sh=~/.acme.sh/acme.sh</code></li><li>自动为你创建 cronjob，每天 0:00 点自动检测所有的证书，如果快过期了，需要更新，则会自动更新证书。</li></ul><h2 id="更改默认证书"><a href="#更改默认证书" class="headerlink" title="更改默认证书"></a>更改默认证书</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">acme.sh --set-default-ca --server letsencrypt</span><br></pre></td></tr></table></figure><p>acme 被 ZeroSSL 收购，其默认的证书方式为 ZeroSSL，但此证书生成时会携带邮箱，因此更换为 letsencrypt。</p><p>当然，也可以在生成证书时加一个<code>--server</code>参数来决定生成什么证书</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--server letsencrypt</span><br></pre></td></tr></table></figure><h2 id="生成证书"><a href="#生成证书" class="headerlink" title="生成证书"></a>生成证书</h2><p>使用<code>acme.sh --issue</code>命令生成证书，但生成证书的同时会进行域名的所有权的验证。 <strong>acme.sh</strong> 有两种方式验证：HTTP 和 DNS 验证。</p><blockquote><p>注意：如果需要生成泛域名（<code>*.example.com</code>）的证书，不能使用 HTTP 认证域名，需要改用 DNS 认证的方式。</p></blockquote><h3 id="HTTP-验证方式"><a href="#HTTP-验证方式" class="headerlink" title="HTTP 验证方式"></a>HTTP 验证方式</h3><p>HTTP 方式需要通过</p><ul><li>配置网站根目录，命令参数为（<code>--webroot /home/wwwroot/example.com/</code>）</li><li>或关联服务器的 <strong>nginx</strong> 服务，命令参数为（<code>--nginx</code>）</li><li>或关联服务器的 <strong>apache</strong> 服务，命令参数为（<code>--apache</code>）</li><li>或自建虚拟 webserver（服务器没有占用 80 端口），命令参数为（<code>--standalone</code>）</li></ul><p>来验证你的域名所有权来完成验证。</p><p>本服务器已搭建 nginx 服务，因此关联即可</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">acme.sh --issue -d example.com -d *.example.com --nginx</span><br></pre></td></tr></table></figure><p>参数解析：</p><ul><li><code>--issue</code>请求证书的签发参数</li><li><code>-d</code>定义需要生成证书的域名，如有多个域名需使用多次</li></ul><p>如果觉得麻烦可以使用第一种配置网站根目录。或者停止占用 80 端口的服务，然后通过添加<code>--standalone</code>参数，等生成证书后再启动原来的服务。如果服务器已有 80 端口的服务，不建议使用自建虚拟 webserver，此方式续租时略麻烦需要改造。</p><h3 id="DNS-验证方式"><a href="#DNS-验证方式" class="headerlink" title="DNS 验证方式"></a>DNS 验证方式</h3><p>需要在域名上添加一条 txt 解析记录，验证域名所有权</p><blockquote><p>DNS 方式的真正强大之处在于可以使用域名解析商提供的 API 自动添加 txt 记录完成验证.</p></blockquote><ol><li><p>在域名提供商中，生成你的 API 令牌</p></li><li><p>引入 API key，以 Cloudflare 为例</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> CF_Key=<span class="string">&quot;1234567890&quot;</span></span><br><span class="line"><span class="built_in">export</span> CF_Email=<span class="string">&quot;123@gmail.com&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>生成证书</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 申请 ECC 证书</span></span><br><span class="line">acme.sh --issue --dns dns_cf -d example.com -d *.example.com</span><br><span class="line"></span><br><span class="line"><span class="comment"># 申请 RSA 证书</span></span><br><span class="line">acme.sh --issue --dns dns_cf -d example.com -d *.example.com -k 2048</span><br></pre></td></tr></table></figure><p> <code>--dns</code>的配置值也是根据域名提供商来决定，dns_cf 表示 cloudflare。</p><p> 不同提供商，API 参数值各不同，可参考下面的表格</p></li></ol><table><thead><tr><th>服务商名称</th><th>服务商简称</th><th>所需API参数</th><th>获取API参数地址</th></tr></thead><tbody><tr><td>cloudxns</td><td>cx</td><td><code>export CX_Key=&quot;123456&quot;</code> <br> <code>export CX_Secret=&quot;abcdef&quot;</code></td><td><a class="link"   href="https://www.cloudxns.net/AccountManage/apimanage.html" >点击访问<i class="fas fa-external-link-alt"></i></a></td></tr><tr><td>dnspod.cn</td><td>dp</td><td><code>export DP_Id=&quot;123456&quot;</code> <br> <code>export DP_Key=&quot;abcdef&quot;</code></td><td><a class="link"   href="https://www.dnspod.cn/console/user/security" >点击访问<i class="fas fa-external-link-alt"></i></a></td></tr><tr><td>aliyun</td><td>ali</td><td><code>export Ali_Key=&quot;123456&quot;</code> <br> <code>export Ali_Secret=&quot;abcdef&quot;</code></td><td><a class="link"   href="https://ak-console.aliyun.com/#/accesskey" >点击访问<i class="fas fa-external-link-alt"></i></a></td></tr><tr><td>cloudflare</td><td>cf</td><td><code>export CF_Key=&quot;123456&quot;</code> <br> <code>export CF_Email=&quot;abc@example.com&quot;</code></td><td><a class="link"   href="https://dash.cloudflare.com/profile/api-tokens" >点击访问<i class="fas fa-external-link-alt"></i></a></td></tr><tr><td>linode</td><td>linode</td><td><code>export LINODE_API_KEY=&quot;123456&quot;</code></td><td><a class="link"   href="https://manager.linode.com/profile/api" >点击访问<i class="fas fa-external-link-alt"></i></a></td></tr><tr><td>he</td><td>he</td><td><code>export HE_Username=&quot;username&quot;</code> <br> <code>export HE_Password=&quot;password&quot;</code></td><td><a class="link"   href="https://dns.he.net/" >he<i class="fas fa-external-link-alt"></i></a> 的用户名密码</td></tr><tr><td>digitalocean</td><td>dgon</td><td><code>export DO_API_KEY=&quot;123456&quot;</code></td><td><a class="link"   href="https://cloud.digitalocean.com/settings/applications" >点击访问<i class="fas fa-external-link-alt"></i></a></td></tr><tr><td>namesilo</td><td>namesilo</td><td><code>export Namesilo_Key=&quot;123456&quot;</code></td><td><a class="link"   href="https://www.namesilo.com/account/api-manager" >点击访问<i class="fas fa-external-link-alt"></i></a></td></tr><tr><td>aws</td><td>aws</td><td><code>export AWS_ACCESS_KEY_ID=123456</code> <br> <code>export AWS_SECRET_ACCESS_KEY=abcdef</code></td><td><a class="link"   href="http://docs.aws.amazon.com/IAM/latest/UserGuide/id_users_create.html" >点击访问<i class="fas fa-external-link-alt"></i></a></td></tr><tr><td>namecom</td><td>namecom</td><td><code>export Namecom_Username=&quot;username&quot;</code> <br> <code>export Namecom_Token=&quot;123456&quot;</code></td><td><a class="link"   href="https://www.name.com/reseller/apply" >点击访问<i class="fas fa-external-link-alt"></i></a></td></tr><tr><td>freedns</td><td>freedns</td><td><code>export FREEDNS_User=&quot;username&quot;</code> <br> <code>export FREEDNS_Password=&quot;password&quot;</code></td><td><a class="link"   href="https://freedns.afraid.org/" >freedns<i class="fas fa-external-link-alt"></i></a> 的用户名密码</td></tr><tr><td>godaddy</td><td>gd</td><td><code>export GD_Key=&quot;123456&quot;</code> <br> <code>export GD_Secret=&quot;abcdef&quot;</code></td><td><a class="link"   href="https://developer.godaddy.com/keys/" >点击访问<i class="fas fa-external-link-alt"></i></a></td></tr><tr><td>yandex</td><td>yandex</td><td><code>export PDD_Token=&quot;abcdef&quot;</code></td><td><a class="link"   href="https://tech.yandex.com/domain/doc/concepts/access-docpage/" >点击访问<i class="fas fa-external-link-alt"></i></a></td></tr></tbody></table><h2 id="安装证书"><a href="#安装证书" class="headerlink" title="安装证书"></a>安装证书</h2><p>默认生成的证书都放在安装目录下: <code>~/.acme.sh/</code>，但是不要在 web 服务器中直接引用目录下的证书文件，也不要手动来拷贝证书文件到具体的 web 服务器中，手动拷贝会导致之后更新证书流程不能完全自动。</p><p>正确方式是使用 acme.sh 的安装证书命令，acme.sh 自动拷贝证书文件到具体目录中，拷贝命令会被记录下来，之后自动更新证书流程也会执行此拷贝步骤，从而实现更新证书流程的完全自动化。</p><p>格式例子如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">acme.sh --install-cert -d example.com -d *.example.com \</span><br><span class="line">    --key-file        /etc/nginx/cert_file/key.pem  \</span><br><span class="line">    --fullchain-file  /etc/nginx/cert_file/fullchain.pem \</span><br><span class="line">    --reloadcmd       <span class="string">&quot;service nginx force-reload&quot;</span></span><br></pre></td></tr></table></figure><p>根据 web 服务器需要的文件按需引入对应的参数，reloadcmd 定义证书更新后重启对应的 web 服务命令。</p><h2 id="更新证书"><a href="#更新证书" class="headerlink" title="更新证书"></a>更新证书</h2><p>目前证书在 60 天以后会自动更新，你无需任何操作，因为在 acme.sh 安装时，已经把相关的自动更新程序写入到 crontab 中，如果想要查看，可以通过以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">crontab -l</span><br></pre></td></tr></table></figure><p>输出内容包含一个自动更新程序，大致内容如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">56 * * * * <span class="string">&quot;/root/.acme.sh&quot;</span>/acme.sh --cron --home <span class="string">&quot;/root/.acme.sh&quot;</span> &gt; /dev/null</span><br></pre></td></tr></table></figure><h2 id="查看证书"><a href="#查看证书" class="headerlink" title="查看证书"></a>查看证书</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">acme.sh --list</span><br></pre></td></tr></table></figure><h2 id="吊销证书"><a href="#吊销证书" class="headerlink" title="吊销证书"></a>吊销证书</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">acme.sh --remove -d example.com *.example.com </span><br></pre></td></tr></table></figure><p>或者手动在<code>~/.acme.sh/</code>目录下删除对应的域名目录，如<code>~/.acme.sh/example.com</code>。</p><h2 id="升级-ACME"><a href="#升级-ACME" class="headerlink" title="升级 ACME"></a>升级 ACME</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">acme.sh --upgrade</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;网站想要升级到HTTPS，首先得申请下发个安全证书，现在下发证书很简单，方式也很多，很多域名提供商都提供免费证书申请。但是，很多证书都是有时间限制（3个月或者1年），时间到期就需要手动重新，手续麻烦而且还会忘记续期，如果想一劳永逸可以用工具自动生成证书并且自动续租。续租工具和方式也很多，本文将讲解用 ACME 实现证书申请和证书自动续期。&lt;/p&gt;</summary>
    
    
    
    <category term="备忘录" scheme="https://lisir.me/hexo-theme-keep/categories/%E5%A4%87%E5%BF%98%E5%BD%95/"/>
    
    
    <category term="ACME" scheme="https://lisir.me/hexo-theme-keep/tags/ACME/"/>
    
  </entry>
  
  <entry>
    <title>Java | 第一阶段</title>
    <link href="https://lisir.me/hexo-theme-keep/posts/1d11e0f7/"/>
    <id>https://lisir.me/hexo-theme-keep/posts/1d11e0f7/</id>
    <published>2024-04-27T01:25:57.000Z</published>
    <updated>2024-09-02T06:10:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>Java 第一阶段</p><span id="more"></span><hr><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>变量相当于内存中一个数据存储空间的表示，你可以把变量看做是一个房间的门牌号，通过门牌号我们可以找到房间，而通过变量名可以访问到变量的值。</p><ul><li>不同的变量，类型不同，占用的空间大小不同。</li><li>变量必须先声明，后使用。</li><li>变量在同一个作用域内不能重名。</li></ul><h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><p>每一种数据都定义了明确的数据类型，在内存中分配了不同大小的内存空间。</p><p><img                         lazyload                       alt="image"                       data-src="https://img.lisir.me/image/posts/1d11e0f7/20240427085447.png"                        alt="20240427085447"                 ></p><h4 id="整数类型"><a href="#整数类型" class="headerlink" title="整数类型"></a>整数类型</h4><ul><li>整数类型有固定的范围和字段长度，不受操作系统的影响。</li><li>整数常量默认为 int 型，声明 long 型常量需要在后面加 <code>l</code> 或 <code>L</code>。</li><li>bit（位）是计算机最小存储单位，byte（字节）是计算机中基本存储单位，1byte 等于 8bit。</li></ul><h4 id="浮点类型"><a href="#浮点类型" class="headerlink" title="浮点类型"></a>浮点类型</h4><ul><li>浮点数 &#x3D; 符号位 + 指数位 + 尾数位</li><li>尾数部分可能丢失，造成精度损失（小数都是近似值）。</li><li>浮点数常量默认为 double 型，声明 float 型常量需要在后面加 <code>f</code> 或 <code>F</code>。</li></ul><h4 id="字符类型"><a href="#字符类型" class="headerlink" title="字符类型"></a>字符类型</h4><ul><li>字符常量是用单引号括起来的单个字符。</li><li>转义字符 <code>\</code> 可以将其后的字符转变为特殊字符常量。</li><li>char 本质是一个整数，在输出时，是 Unicode 码对应的字符。</li><li>可以直接给 char 赋一个整数，然后输出时，会按照对应的 Unicode 字符输出。</li><li>char 是可以进行运算的，相当于一个整数。</li></ul><h4 id="布尔类型"><a href="#布尔类型" class="headerlink" title="布尔类型"></a>布尔类型</h4><ul><li>布尔类型数据只允许取值 <code>true</code> 和 <code>false</code>，没有 <code>null</code>。</li></ul><h3 id="基本数据类型转换"><a href="#基本数据类型转换" class="headerlink" title="基本数据类型转换"></a>基本数据类型转换</h3><p>精度就是这个类型在内存中分配的内存空间，也就是容量。</p><h4 id="自动类型转换"><a href="#自动类型转换" class="headerlink" title="自动类型转换"></a>自动类型转换</h4><p>在进行赋值或者运算时，精度小的类型自动转换为精度大的数据类型。</p><ul><li>char ---&gt; int ---&gt; long ---&gt; float ---&gt; double</li><li>byte ---&gt; short ---&gt; int ---&gt; long ---&gt; float ---&gt; double</li></ul><p>注意细节：</p><ul><li>多种类型的数据混合运算时，系统首先自动将所有的数据转换成精度最大的那种数据类型，然后再进行计算。</li><li>把精度大的数据类型赋值给精度小的数据类型时，就会报错，反之就会进行自动类型转换。</li><li>在进行赋值时，byte 或 short 与 char 之间不会相互自动转换。</li><li>byte、short、char 它们三者可以进行混合运算，在运算时首先转换为 int 类型。</li><li>boolean 不参与转换。</li><li>表达式结果的类型自动提升为操作数中精度最大的类型。</li></ul><h4 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h4><p>自动类型转换的逆过程，将精度大的数据类型转换为精度小的数据类型。<br>使用时要加上强制转换符 <code>()</code>，但可能造成精度降低或溢出，格外要注意。</p><p>注意细节：</p><ul><li>强转符号只针对最近的操作数有效，多个操作数往往会使用小括号提升优先级。</li><li>char 可以保存 int 的常量值，但不能保存 int 的变量值，需要强转。</li><li>byte、short、char 在进行运算时，当做 int 处理。</li></ul><h4 id="转-String-类型"><a href="#转-String-类型" class="headerlink" title="转 String 类型"></a>转 String 类型</h4><ul><li>基本数据类型转 String 类型：将基本数据类型的值 + <code>&quot;&quot;</code> 即可。</li><li>String 类型转基本数据类型：通过基本数据类型的包装类调用 parseXxx 方法即可。</li></ul><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><p>运算符是一种特殊的符号，用以表示数据的运算、赋值和比较等。</p><h3 id="算数运算符"><a href="#算数运算符" class="headerlink" title="算数运算符"></a>算数运算符</h3><p>算术运算符是对数值类型的变量进行运算的，在 Java 程序中使用的非常多。</p><p><img                         lazyload                       alt="image"                       data-src="https://img.lisir.me/image/posts/1d11e0f7/20240427131216.png"                        alt="20240427131216"                 ></p><p>注意细节：</p><blockquote><ul><li>对于除号 <code>/</code>，它的整数除和小数除是有区别的，整数之间做除法时，只保留整数部分舍弃小数部分。</li><li>取模 <code>%</code> 的本质，<code>a % b</code> 等于 <code>a - (int)(a / b) * b</code>。</li></ul></blockquote><p><code>+</code> 号的使用：</p><blockquote><ul><li>当左右两边都是数值型时，则做加法运算。</li><li>当左右两边有一方为字符串时，则做拼接运算。</li><li>运算顺序是从左到右。</li></ul></blockquote><h3 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h3><p>关系运算符的结果都是 boolean 型，也就是要么是 true，要么是 false。<br>关系表达式经常用在 if 结构的条件中或循环结构的条件中。<br>关系运算符组成的表达式，我们称为关系表达式。</p><p><img                         lazyload                       alt="image"                       data-src="https://img.lisir.me/image/posts/1d11e0f7/20240430091938.png"                        alt="20240430091938"                 ></p><h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><p>用于连接多个条件表达式，最终的结果也是一个 boolean 值。</p><p><img                         lazyload                       alt="image"                       data-src="https://img.lisir.me/image/posts/1d11e0f7/20240430092401.png"                        alt="20240430092401"                 ></p><p>运算规则：</p><blockquote><ul><li><code>a &amp; b</code> 逻辑与：当 a 和 b 同时为 true，则结果为 true，否则为 false。</li><li><code>a &amp;&amp; b</code> 短路与：当 a 和 b 同时为 true，则结果为 true，否则为 false。</li><li><code>a | b</code> 逻辑或：当 a 和 b 有一个为 true，则结果为 true，否则为 false。</li><li><code>a || b</code> 短路或：当 a 和 b 有一个为 true，则结果为 true，否则为 false。</li><li><code>a ^ b</code> 逻辑异或：当 a 和 b 不同时，则结果为 true，否则为 false。</li><li><code>!a</code> 取反，或者非运算：当 a 为 true，则结果为 false，当 a 为 false 是，结果为 true。</li></ul></blockquote><p><code>&amp;&amp;</code> 与 <code>&amp;</code> 的区别：</p><blockquote><ul><li><code>&amp;</code> 逻辑与：不管第一个条件是否为 false，第二个条件都要判断，效率低。</li><li><code>&amp;&amp;</code> 短路与：如果第一个条件为 false，则第二个条件不会判断，最终结果为 false，效率高。</li></ul></blockquote><p><code>||</code> 与 <code>|</code> 的区别：</p><blockquote><ul><li><code>|</code> 逻辑或：不管第一个条件是否为 true，第二个条件都要判断，效率低。</li><li><code>||</code> 短路或：如果第一个条件为 true，则第二个条件不会判断，最终结果为 true，效率高。</li></ul></blockquote><h3 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h3><ul><li>基本赋值运算符：<code>=</code></li><li>复合赋值运算符：<code>+=</code>，<code>-=</code>，<code>*=</code>，<code>/=</code>，<code>%=</code> 等。</li></ul><p>注意细节：</p><ul><li>运算顺序从右往左。</li><li>赋值运算符的左边只能是变量，右边可以是变量、表达式、常量值。</li></ul><h3 id="三元运算符"><a href="#三元运算符" class="headerlink" title="三元运算符"></a>三元运算符</h3><p>条件表达式 ? 表达式一 : 表达式二;</p><p>运算规则：</p><ul><li>如果条件表达式为 true，运算后的结果是表达式一。</li><li>如果条件表达式为 false，运算后的结果是表达式二。</li></ul><h3 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h3><h3 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h3><p>运算符有不同的优先级，所谓优先级就是表达式运算中的运算顺序。<br>只有单目运算符、赋值运算符是从右向左运算的。<br>如下表，上一行运算符总优先于下一行。</p><h2 id="控制结构"><a href="#控制结构" class="headerlink" title="控制结构"></a>控制结构</h2><h3 id="顺序控制"><a href="#顺序控制" class="headerlink" title="顺序控制"></a>顺序控制</h3><h3 id="分支控制"><a href="#分支控制" class="headerlink" title="分支控制"></a>分支控制</h3><h4 id="双分支"><a href="#双分支" class="headerlink" title="双分支"></a>双分支</h4><h4 id="嵌套分支"><a href="#嵌套分支" class="headerlink" title="嵌套分支"></a>嵌套分支</h4><h4 id="switch-分支"><a href="#switch-分支" class="headerlink" title="switch 分支"></a>switch 分支</h4><h3 id="循环控制"><a href="#循环控制" class="headerlink" title="循环控制"></a>循环控制</h3><h4 id="for"><a href="#for" class="headerlink" title="for"></a>for</h4><h4 id="while"><a href="#while" class="headerlink" title="while"></a>while</h4><h4 id="do-while"><a href="#do-while" class="headerlink" title="do...while"></a>do...while</h4><h2 id="数组的排序和查找"><a href="#数组的排序和查找" class="headerlink" title="数组的排序和查找"></a>数组的排序和查找</h2><h2 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h2>]]></content>
    
    
    <summary type="html">&lt;p&gt;Java 第一阶段&lt;/p&gt;</summary>
    
    
    
    <category term="学习笔记" scheme="https://lisir.me/hexo-theme-keep/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Java" scheme="https://lisir.me/hexo-theme-keep/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>英语精读</title>
    <link href="https://lisir.me/hexo-theme-keep/posts/9a718705/"/>
    <id>https://lisir.me/hexo-theme-keep/posts/9a718705/</id>
    <published>2024-01-12T06:59:46.000Z</published>
    <updated>2024-09-02T06:10:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>todo</p><span id="more"></span><h2 id="如何进行精读"><a href="#如何进行精读" class="headerlink" title="如何进行精读"></a>如何进行精读</h2><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><ul><li>第一步：弄懂每句话的结构和生词的意思与词性</li><li>第二步：复习，通读一遍</li><li>第三步：抄写一遍</li></ul><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><ul><li>第四步：模仿造句，模仿是学语言不可或缺</li><li>第五步：大声朗读，带录音，音频的精读课材料</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;todo&lt;/p&gt;</summary>
    
    
    
    <category term="学习笔记" scheme="https://lisir.me/hexo-theme-keep/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="英语精读" scheme="https://lisir.me/hexo-theme-keep/tags/%E8%8B%B1%E8%AF%AD%E7%B2%BE%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>学习笔记 | 英语语法</title>
    <link href="https://lisir.me/hexo-theme-keep/posts/d3f8bfd7/"/>
    <id>https://lisir.me/hexo-theme-keep/posts/d3f8bfd7/</id>
    <published>2024-01-03T03:59:46.000Z</published>
    <updated>2024-10-04T12:26:58.000Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="/hexo-theme-keep/posts/6f1261c3/">英语语法 | 句子成分</a></li><li><a href="/hexo-theme-keep/posts/84c90a91/">英语语法 | 简单句</a></li><li><a href="/hexo-theme-keep/posts/78cf5cff/">英语语法 | 词性</a></li><li><a href="/hexo-theme-keep/posts/26b33495/">英语语法 | 时态</a></li><li><a href="/hexo-theme-keep/posts/9e47et28/">英语语法 | 语态</a></li><li><a href="/hexo-theme-keep/posts/b86ba424/">英语语法 | 语气</a></li><li><a href="/hexo-theme-keep/posts/5b824013/">英语语法 | 复合句</a></li><li><a href="/hexo-theme-keep/posts/81c4e30a/">英语语法</a></li><li><a href="/hexo-theme-keep/posts/9a718705/">英语精读</a></li></ul><span id="more"></span><h2 id="To-Do"><a href="#To-Do" class="headerlink" title="To Do"></a>To Do</h2><ul><li><input disabled="" type="checkbox"> 独立主格</li><li><input disabled="" type="checkbox"> 现在进行表将来</li><li><input disabled="" type="checkbox"> 替代动词 do</li></ul>]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;/hexo-theme-keep/posts/6f1261c3/&quot;&gt;英语语法 | 句子成分&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/hexo-theme-keep/posts/84c90a91/&quot;&gt;英语语法 | 简单句&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/hexo-theme-keep/posts/78cf5cff/&quot;&gt;英语语法 | 词性&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/hexo-theme-keep/posts/26b33495/&quot;&gt;英语语法 | 时态&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/hexo-theme-keep/posts/9e47et28/&quot;&gt;英语语法 | 语态&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/hexo-theme-keep/posts/b86ba424/&quot;&gt;英语语法 | 语气&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/hexo-theme-keep/posts/5b824013/&quot;&gt;英语语法 | 复合句&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/hexo-theme-keep/posts/81c4e30a/&quot;&gt;英语语法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/hexo-theme-keep/posts/9a718705/&quot;&gt;英语精读&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="学习笔记" scheme="https://lisir.me/hexo-theme-keep/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="英语语法" scheme="https://lisir.me/hexo-theme-keep/tags/%E8%8B%B1%E8%AF%AD%E8%AF%AD%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>英语语法 | 语气</title>
    <link href="https://lisir.me/hexo-theme-keep/posts/b86ba424/"/>
    <id>https://lisir.me/hexo-theme-keep/posts/b86ba424/</id>
    <published>2024-01-02T01:57:46.000Z</published>
    <updated>2024-09-02T06:10:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>语气是谓语动词的一种形式，表示说话人对某一行为或者事情的看法和态度。<br>主要的三种语气：陈述语气、祈使语气、虚拟语气。<br>其他语气：疑问语气、条件语气、感叹语气。</p><span id="more"></span><hr><h2 id="陈述语气"><a href="#陈述语气" class="headerlink" title="陈述语气"></a>陈述语气</h2><p>以句号结尾。</p><ul><li>肯定句</li><li>否定句</li></ul><h2 id="疑问语气"><a href="#疑问语气" class="headerlink" title="疑问语气"></a>疑问语气</h2><ul><li>一般疑问句<ul><li>必须用 Yes or No 回答的句子</li></ul></li><li>特殊疑问句<ul><li>特殊疑问词开头的句子</li></ul></li><li>选择疑问句<ul><li>必须有选择连词 or</li></ul></li><li>反意疑问句<ul><li>也叫附加疑问句，陈述句 + 逗号 + 小疑问句 + 问号</li></ul></li></ul><h2 id="祈使语气"><a href="#祈使语气" class="headerlink" title="祈使语气"></a>祈使语气</h2><p>祈使句：</p><blockquote><ul><li>没有主语，谓语动词用原形开头的句子。</li><li>表示说话人向对方提出的请求、邀请，给予忠告、指示、警告，发出警告等。</li><li>语气强烈的时候，一般用感叹号，其他情况可以用句号。</li><li>通常没有主语，有时候也会加上 you 表示强调。</li></ul></blockquote><p>构成方式：</p><blockquote><ul><li>（Don&#39;t +）及物动词原形 + 宾语（+ 状语）</li><li>（Don&#39;t +）不及物动词原形（+ 状语）</li><li>（Don&#39;t +）be + 表语（+ 状语）</li></ul></blockquote><h2 id="虚拟语气"><a href="#虚拟语气" class="headerlink" title="虚拟语气"></a>虚拟语气</h2><p>动作或者状态不是客观存在的事实，而是说话人的主观愿望，假设、假想或推测。<br>虚拟语气其实就是那些不真实或者不可能发生的假设。</p><h3 id="假设的情况"><a href="#假设的情况" class="headerlink" title="假设的情况"></a>假设的情况</h3><table><thead><tr><th>假设的情况</th><th>主语谓语形式</th><th>从句谓语形式</th></tr></thead><tbody><tr><td>与过去事实相反</td><td>should&#x2F;would&#x2F;could&#x2F;might+have+过去分词</td><td>had+过去分词</td></tr><tr><td>与现在事实相反</td><td>should&#x2F;would&#x2F;could&#x2F;might+动词原形</td><td>动词过去式&#x2F;were</td></tr><tr><td>与将来事实相反</td><td>should&#x2F;would&#x2F;could&#x2F;might+动词原形</td><td>1. 动词过去式&#x2F;were <br> 2. should+动词原形 <br> 3. were to+动词原形</td></tr></tbody></table><blockquote><p>shall(原形)——&gt;should(过去式)<br>will(原形)——&gt;would(过去式)<br>can(原形)——&gt;could(过去式)<br>may(原形)——&gt;might(过去式)</p></blockquote><p>与过去的事实相反：</p><blockquote><ul><li>主句构成方式：<ul><li>主语 + would&#x2F;should&#x2F;could&#x2F;might + have + 实义动词过去分词（+ 宾语）</li><li>主语 + would&#x2F;should&#x2F;could&#x2F;might + have + been + 表语</li></ul></li><li>从句构成方式：<ul><li>If + 主语 + had + 实义动词过去分词（+ 宾语）+ 表示过去的时间状语</li><li>If + 主语 + had + been + 表语 + 表示过去的时间状语</li></ul></li></ul></blockquote><p>与现在的事实相反：</p><blockquote><ul><li>主句构成方式：<ul><li>主语 + would&#x2F;should&#x2F;could&#x2F;might + 实义动词原形（+ 宾语）</li><li>主语 + would&#x2F;should&#x2F;could&#x2F;might + be + 表语</li></ul></li><li>从句构成方式：<ul><li>If + 主语 + 实义动词过去式（+ 宾语）+ 表示现在的时间状语</li><li>If + 主语 + were + 表语 + 表示现在的时间状语</li></ul></li></ul></blockquote><p>与将来的事实相反：</p><blockquote><ul><li>主句构成方式：<ul><li>主语 + would&#x2F;should&#x2F;could&#x2F;might + 实义动词原形（+ 宾语）</li><li>主语 + would&#x2F;should&#x2F;could&#x2F;might + be + 表语</li></ul></li><li>从句构成方式：<ul><li>If + 主语 + 实义动词过去式（+ 宾语）+ 表示将来的时间状语</li><li>If + 主语 + should + 实义动词原形（+ 宾语）+ 表示将来的时间状语</li><li>If + 主语 + were + 表语 + 表示将来的时间状语</li></ul></li></ul></blockquote><h3 id="其他情况"><a href="#其他情况" class="headerlink" title="其他情况"></a>其他情况</h3><p>主句和从句的动作发生的时间不一致的情况：</p><blockquote><ul><li>与过去的事实相反的从句构成方式 + 与现在的事实相反的主句构成方式</li></ul></blockquote><p>虚拟条件状语从句省略连接词 if 的情况：</p><blockquote><ul><li>书面语中，如果虚拟条件状语从句中有 were、had 或 should，<br>可以把 if 省略，但是要把这几个词移到主语的前面，构成主谓倒装。</li><li>省略 if 的虚拟条件状语从句，句首不能用助动词的缩略否定形式。</li></ul></blockquote><p>用介词短语代替虚拟条件状语从句：</p><blockquote><ul><li>一些表示“条件”的词或短语，如 with、without、but for、but that、in case of、<br>under more favorable condition、in the absence of 等，可以暗示虚拟条件的存在。</li></ul></blockquote><p>省略条件状语从句或主句：</p><blockquote><ul><li>表示虚拟语气的主句或者条件状语从句有时可以省略，但是虚拟的意义还在。</li><li>省略主句只保留 if 引导的虚拟条件状语从句，一般表示某种不可能实现的愿望。</li><li>不管句子是省略主句还是从句，谓语动词必须符合虚拟语气的构成方式。</li></ul></blockquote><p>特殊情况：</p><blockquote><ul><li>有时候虚拟语气只是表示委婉或礼貌一点，不一定是不真实的情况。</li><li>有时候 should 跟 would 是同义词，都是一个助动词，没有意思。</li></ul></blockquote><h3 id="其他用法"><a href="#其他用法" class="headerlink" title="其他用法"></a>其他用法</h3><p>在宾语从句的用法：</p><blockquote><ul><li>一般只有 wish 后面跟一个 that 引导的宾语从句才会有虚拟的情况。</li><li>主句中的 wish 不用虚拟，只有宾语从句里面使用虚拟语气的结构。</li><li>复合句句型为：主语 + wish + that 引导的虚拟宾语从句</li><li>一般情况下，宾语从句通常省略 that 连接词。</li></ul></blockquote><p>虚拟宾语从句三种情况：</p><blockquote><ul><li>与现在的事实相反<ul><li>主语 + wish&#x2F;wishes +（that +）主语 + 实义动词过去式（+ 宾语）+ 状语</li><li>主语 + wish&#x2F;wishes +（that +）主语 + were + 实义动词现在分词（+ 宾语）+ 状语</li><li>主语 + wish&#x2F;wishes +（that +）主语 + were + 表语 + 状语</li></ul></li><li>与过去的事实相反<ul><li>主语 + wish&#x2F;wishes +（that +）主语 + had + 实义动词过去分词（+ 宾语）+ 表示过去的时间状语</li><li>主语 + wish&#x2F;wishes +（that +）主语 + had + been + 表语 + 表示过去的时间状语</li></ul></li><li>对将来的主观愿望<ul><li>主语 + wish&#x2F;wishes +（that +）另一个主语 + would + 实义动词原形（+ 宾语）+ 表示将来的时间状语</li><li>主语 + wish&#x2F;wishes +（that +）另一个主语 + would+ be + 表语 + 表示将来的时间状语</li></ul></li></ul></blockquote><p>在其他状语从句中的用法：</p><blockquote><ul><li>even if&#x2F;even though 引导的让步状语从句也可以出现虚拟语气，<br>主句和让步状语从句都用虚拟结构，构成方式和含有虚拟条件状语从句的复合句一样。</li><li>as if&#x2F;as though 引导的方式状语从句也可以出现虚拟语气，<br>主句不需要虚拟，从句和虚拟条件状语从句构成方式一样。</li></ul></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;语气是谓语动词的一种形式，表示说话人对某一行为或者事情的看法和态度。&lt;br&gt;主要的三种语气：陈述语气、祈使语气、虚拟语气。&lt;br&gt;其他语气：疑问语气、条件语气、感叹语气。&lt;/p&gt;</summary>
    
    
    
    <category term="学习笔记" scheme="https://lisir.me/hexo-theme-keep/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="英语语法" scheme="https://lisir.me/hexo-theme-keep/tags/%E8%8B%B1%E8%AF%AD%E8%AF%AD%E6%B3%95/"/>
    
    <category term="语气" scheme="https://lisir.me/hexo-theme-keep/tags/%E8%AF%AD%E6%B0%94/"/>
    
  </entry>
  
  <entry>
    <title>英语语法 | 句子成分</title>
    <link href="https://lisir.me/hexo-theme-keep/posts/6f1261c3/"/>
    <id>https://lisir.me/hexo-theme-keep/posts/6f1261c3/</id>
    <published>2023-12-24T11:57:46.000Z</published>
    <updated>2024-09-02T06:10:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>英语九大句子成分：</p><table><thead><tr><th>成分</th><th>简写</th></tr></thead><tbody><tr><td>主语</td><td>S</td></tr><tr><td>谓语</td><td>V</td></tr><tr><td>表语</td><td>P</td></tr><tr><td>宾语</td><td>O</td></tr><tr><td>宾补</td><td>OC</td></tr><tr><td>状语</td><td>ADV</td></tr><tr><td>定语</td><td>ATT</td></tr><tr><td>同位语</td><td>AP</td></tr><tr><td>独立成分</td><td></td></tr></tbody></table><span id="more"></span><hr><h2 id="主语"><a href="#主语" class="headerlink" title="主语"></a>主语</h2><p>一个句子叙述的主体，一句话主要叙述的对象或者这句话主要讲的内容。</p><p>能作主语的词语：</p><blockquote><ul><li>名词</li><li>数词</li><li>人称代词</li><li>指示代词</li><li>动名词及短语</li><li>动词不定式及短语</li><li>名词性从句</li><li>名词短语</li></ul></blockquote><h2 id="谓语"><a href="#谓语" class="headerlink" title="谓语"></a>谓语</h2><p>说明主语动作或者状态的词语。<br>说明主语做什么或者主语是什么，主语怎么样的词语。<br>谓语只跟主语有关，说明主语的情况，跟其他成分没有关系。</p><h3 id="动作型谓语"><a href="#动作型谓语" class="headerlink" title="动作型谓语"></a>动作型谓语</h3><p>说明主语做什么的，由动词构成的。比如：</p><blockquote><ul><li>I eat an apple every day（我每天吃一个苹果）及物动词 eat 作动作型谓语。</li></ul></blockquote><h4 id="简单谓语"><a href="#简单谓语" class="headerlink" title="简单谓语"></a>简单谓语</h4><p>简单谓语由实义动词或者短语动词（复合动词）构成。比如：</p><blockquote><ul><li>I run every day（我每天跑步）实义动词 run 作谓语。</li><li>I get up at six（我六点起床）短语动词 get up 作谓语。</li></ul></blockquote><h4 id="复合谓语"><a href="#复合谓语" class="headerlink" title="复合谓语"></a>复合谓语</h4><p>复合谓语就是由简单谓语加上其他词语共同作谓语的情况。</p><blockquote><ul><li>情态动词 + 实义动词原型&#x2F;短语动词原型：<ul><li>I can speak Mandarin（我会说普通话）情态动词 can 和实义动词 speak 构成复合谓语。</li><li>I can look after her（我可以照顾她）情态动词 can 和短语动词 look after 构成复合谓语。</li></ul></li><li>助动词 + 实义动词原型&#x2F;短语动词原型：<ul><li>I will buy a new book tomorrow（我明天要买一本新书）助动词 will 和实义动词 buy 构成复合谓语。</li><li>I will get up early tomorrow（我明天要早起）助动词 will 和短语动词 get up 构成复合谓语。</li></ul></li><li>助动词 + 其他的动词形式：<ul><li>I am working now（我现在正在工作）助动词 am 和不及物动词现在分词 working 构成复合谓语。</li></ul></li></ul></blockquote><h3 id="状态型谓语"><a href="#状态型谓语" class="headerlink" title="状态型谓语"></a>状态型谓语</h3><p>说明主语是什么或者怎么样的，由系表结构构成的。比如：</p><blockquote><ul><li>I am happy（我高兴）系动词 am 和形容词 happy 作表语构成状态型谓语。</li></ul></blockquote><p>从某种意义上，系动词加表语也是一种复合谓语。</p><blockquote><ul><li>be + 名词：<ul><li>He is a doctor（他是一名医生）系动词 is 和名词 a doctor 作表语构成状态型谓语。</li></ul></li><li>be + 形容词：<ul><li>I am happy（我快乐）系动词 am 和形容词 happy 作表语构成状态型谓语。</li></ul></li><li>be + 介词短语：<ul><li>I am in China（我在中国）系动词 am 和介词短语 in China 作表语构成状态型谓语。</li></ul></li></ul></blockquote><h2 id="宾语"><a href="#宾语" class="headerlink" title="宾语"></a>宾语</h2><p>及物动词这个动作的对象或承受着。<br>能作主语的词语都可以作宾语，不能作主语的词语同样不能作宾语。</p><h3 id="并列宾语"><a href="#并列宾语" class="headerlink" title="并列宾语"></a>并列宾语</h3><p>即多个词语并列作宾语。比如：</p><blockquote><ul><li>I like money, beautiful clothes and rich men（我喜欢金钱、漂亮的衣服和有钱的男人）其中 money、beautiful clothes、rich men 并列在一起作并列宾语。</li></ul></blockquote><h3 id="双宾语"><a href="#双宾语" class="headerlink" title="双宾语"></a>双宾语</h3><p>双宾动词后面跟两个宾语，表示物的叫直接宾语，表示人的叫间接宾语。比如：</p><blockquote><ul><li>I gave her a book（我给她一本书）双宾动词 gave 后面的 a book 是直接宾语，her 是间接宾语。</li></ul></blockquote><h2 id="表语"><a href="#表语" class="headerlink" title="表语"></a>表语</h2><p>表语用来表述主语的身份、状态、性质等信息。<br>表语属于谓语的范畴，但是不能说表语就是谓语，因为系动词加表语（系表结构）才是谓语，系动词和表语构成状态型谓语。<br>系动词和表语是不能分开的，没有系动词就没有表语，没有表语就没有系动词。</p><p>能作表语的词语：</p><blockquote><ul><li>名词：<ul><li>I am a teacher（我是一个老师）名词 teacher 作表语。</li></ul></li><li>形容词：<ul><li>I am rich（我有钱）形容词 rich 作表语。</li></ul></li><li>介词短语：<ul><li>She is in China（她在中国）介词短语 in China 作表语。</li></ul></li><li>名词所有格</li><li>动名词及短语</li><li>动词不定式及短语</li><li>名词性从句</li><li>代词</li><li>数词</li><li>分词</li><li>副词</li></ul></blockquote><h2 id="补语"><a href="#补语" class="headerlink" title="补语"></a>补语</h2><p>起补充说明作用的成份。</p><h3 id="宾语补足语"><a href="#宾语补足语" class="headerlink" title="宾语补足语"></a>宾语补足语</h3><p>简称宾补，补充说明宾语，使其意思更完整。</p><p>宾补只跟宾语有关系。比如：</p><blockquote><ul><li>I made her happy（我让她开心）形容词 happy 作宾补。</li></ul></blockquote><p>能作宾补的词语：</p><blockquote><ul><li>名词：<ul><li>I call her Mary（我叫她玛丽）名词 Mary 作宾补。</li></ul></li><li>数词：<ul><li>I put my family first（我把家庭放在第一位）数词 first 作宾补。</li></ul></li><li>形容词：<ul><li>You make me mad（你让我发疯）形容词 mad 作宾补。</li></ul></li><li>介词短语</li><li>动名词及短语</li><li>动词不定式及短语</li><li>名词性从句</li><li>副词</li><li>分词</li></ul></blockquote><h3 id="主语补足语"><a href="#主语补足语" class="headerlink" title="主语补足语"></a>主语补足语</h3><p>简称主补。</p><h2 id="定语"><a href="#定语" class="headerlink" title="定语"></a>定语</h2><p>修饰或限定名词的词语。<br>定语只跟名词有关系，哪里有名词哪里就有定语。<br>同一个名词可以有多个定语。</p><h3 id="前置定语"><a href="#前置定语" class="headerlink" title="前置定语"></a>前置定语</h3><p>放在名词前面的定语。</p><p>能作前置定语的词语：</p><blockquote><ul><li>数词：<ul><li>three books（三本书）数词 three 作前置定语。</li></ul></li><li>量词：<ul><li>a bottle of water（一瓶水）量词 a bottle of 作前置定语。</li></ul></li><li>名词：<ul><li>English book（英语书）名词 English 作前置定语。</li></ul></li><li>形容词：<ul><li>happy girl（快乐的女孩）形容词 happy 作前置定语。</li></ul></li><li>指示代词：<ul><li>this book（这本书）指示代词 this 作前置定语。</li></ul></li><li>名词所有格：<ul><li>Nick&#39;s house（Nick 的房子）名词所有格 Nick&#39;s 作前置定语。</li></ul></li><li>形容词性物主代词：<ul><li>my book（我的书）形容词性物主代词 my 作前置定语。</li></ul></li></ul></blockquote><h3 id="后置定语"><a href="#后置定语" class="headerlink" title="后置定语"></a>后置定语</h3><p>放在名词后面修饰前面的名词的定语。</p><p>能作后置定语的词语：</p><blockquote><ul><li>介词短语</li><li>名词所有格</li><li>动名词及短语</li><li>动词不定式及短语</li><li>形容词性从句</li></ul></blockquote><h2 id="状语"><a href="#状语" class="headerlink" title="状语"></a>状语</h2><p>状语用来修饰谓语，说明谓语的情况。<br>状语只跟谓语有关系，一般由副词和介词短语充当放在句子的后面。</p><p>状语的数量是不定的，出现多个状语时，排列顺序为：</p><blockquote><ul><li>方式状语 &gt; 地点状语 &gt; 时间状语</li></ul></blockquote><p>状语的分类：</p><blockquote><ul><li>时间状语：<ul><li>I am happy today（我今天开心）时间副词 today 作时间状语。</li></ul></li><li>地点状语：<ul><li>I learn English at home（我在家学英语）介词短语 at home 作地点状语。</li></ul></li><li>方式状语：<ul><li>I speak English slowly（我慢慢地说英语）方式副词 slowly 作方式状语。</li></ul></li><li>原因状语</li><li>目的状语</li><li>结果状语</li><li>伴随状语</li></ul></blockquote><h2 id="同位语"><a href="#同位语" class="headerlink" title="同位语"></a>同位语</h2><p>两个不同的词语都表示同一个人或事物。</p><p>同位语起到强调补充说明的作用。比如：</p><blockquote><ul><li>My father, the fat man, is drinking（我爸爸，就是那个胖男人，正在喝酒）其中 the fat man 就是 my father 的同位语。</li></ul></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;英语九大句子成分：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;成分&lt;/th&gt;
&lt;th&gt;简写&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;主语&lt;/td&gt;
&lt;td&gt;S&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;谓语&lt;/td&gt;
&lt;td&gt;V&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;表语&lt;/td&gt;
&lt;td&gt;P&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;宾语&lt;/td&gt;
&lt;td&gt;O&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;宾补&lt;/td&gt;
&lt;td&gt;OC&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;状语&lt;/td&gt;
&lt;td&gt;ADV&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;定语&lt;/td&gt;
&lt;td&gt;ATT&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;同位语&lt;/td&gt;
&lt;td&gt;AP&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;独立成分&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;</summary>
    
    
    
    <category term="学习笔记" scheme="https://lisir.me/hexo-theme-keep/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="英语语法" scheme="https://lisir.me/hexo-theme-keep/tags/%E8%8B%B1%E8%AF%AD%E8%AF%AD%E6%B3%95/"/>
    
    <category term="句子成分" scheme="https://lisir.me/hexo-theme-keep/tags/%E5%8F%A5%E5%AD%90%E6%88%90%E5%88%86/"/>
    
  </entry>
  
  <entry>
    <title>英语语法 | 复合句</title>
    <link href="https://lisir.me/hexo-theme-keep/posts/5b824013/"/>
    <id>https://lisir.me/hexo-theme-keep/posts/5b824013/</id>
    <published>2023-12-24T11:57:46.000Z</published>
    <updated>2024-09-02T06:10:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>又称主从复合句，由一个主句和一个及以上的从句构成。<br>从句不能独立存在，必须作整个复合句中的某个句子成分。<br>从句一般需要连接词引导，但有时候可能会被省略。</p><span id="more"></span><hr><h2 id="名词性从句"><a href="#名词性从句" class="headerlink" title="名词性从句"></a>名词性从句</h2><p>在句子中起到名词作用的句子，相当于一个“大名词”。<br>主语、表语、宾语、同位语从句的构成方式、意思、使用的连接词都一样。</p><p>名词性从句的连接词分为：</p><blockquote><ul><li>从属连词<ul><li>that：无词义，在从句中不担任成分。</li><li>if、whether：有词义，在从句中不担任成分。</li></ul></li><li>连接代词<ul><li>who、whom、whose、what、which：有词义，在从句中做主语、表语、宾语、或定语。</li></ul></li><li>连接副词<ul><li>when、where、why、how：有词义，在从句中做状语。</li></ul></li></ul></blockquote><p>感叹句充当名词性从从句：</p><blockquote><ul><li>感叹句去掉感叹号可以直接相当于一个名词性从句，在复合句中主要做宾语从句。</li></ul></blockquote><p>某些特殊疑问句充当名词性从句：</p><blockquote><ul><li>how many</li><li>how much</li><li>how often</li><li>how long</li><li>how far</li></ul></blockquote><h3 id="主语从句"><a href="#主语从句" class="headerlink" title="主语从句"></a>主语从句</h3><p>主语从句可以是动作型的句子也可以是状态型的句子。<br>在复合句中，主语从句属于第三人称单数的概念。</p><blockquote><p>主语从句后置的情形：名词性从句做主语时，在结构形式上会给人一种头重脚轻的感觉，为避免这种句式结构的不平衡，常借用代词 it 来代替此名词性从句，而将此从句进行后置，这时的 it 就是形式主语（假主语），真正的主语是后置的主语从句（真主语）。</p></blockquote><ul><li>从属连词<ul><li>that：没有意思，在从句中不充当任何句子成分。</li><li>whether(是否)：在从句中不充当任何句子成分。引导的从句既可以前置也可以后置。</li><li>if(是否)：在从句中不充当任何句子成分。引导的从句只能后置。</li></ul></li><li>连接代词<ul><li>who(谁)、whoever(无论谁)：在主语从句中做表语。</li><li>what(……的)、whatever(无论什么)：在主语从句中可以做主语、宾语，少数情况可以做表语。</li><li>which(哪个)、whose(谁的)：在主语从句中做定语，后面必须修饰一个普通名词。</li><li>whom(谁)：在从句中只能做宾语。</li></ul></li><li>连接副词<ul><li>when(什么时候)：在从句中做时间状语。</li><li>where(在哪里)：在从句中做地点状语。</li><li>why(为什么)：在从句中做原因状语。</li><li>how(如何)：在从句中做方式状语。</li></ul></li></ul><h3 id="表语从句"><a href="#表语从句" class="headerlink" title="表语从句"></a>表语从句</h3><p>主语从句的构成方式和连接词跟表语从句一样，可以直接做表语从句。<br>含有表语从句的复合句的主语不能是人或者有生命的事物。</p><h3 id="宾语从句"><a href="#宾语从句" class="headerlink" title="宾语从句"></a>宾语从句</h3><p>宾语从句是最常用的从句之一。</p><p>宾语从句的时态取决于主句的时态：</p><blockquote><ul><li>主句使用现在时态时，宾语从句可以使用任何时态。</li><li>主句用一般过去时态，宾语从句全部要用过去时态。</li><li>例外：当宾语从句表示“真理”，可以用一般现在时态，不受主句时态影响。</li></ul></blockquote><p>直接引语和间接引语：</p><blockquote><p>重述别人所说的话时可采用两种方式：</p><ul><li>直接引语：即用引号直接引述别人的原话。</li><li>间接引语：即用自己的话转述别人的话。可以直接作宾语从句。</li></ul></blockquote><p>注意：</p><blockquote><p>what 在主语从句和表语从句中不能翻译为“什么”，在宾语从句中有时候可以翻译为“什么”。</p></blockquote><h3 id="同位语从句"><a href="#同位语从句" class="headerlink" title="同位语从句"></a>同位语从句</h3><p>当一个从句来充当同位语时，那么这个从句就是同位语从句。<br>所谓同位语就是用不同的方式把一个概念再说一遍，用逗号隔开。<br>其作用与简单句中的同位语一致，用于补充说明名词或代词。<br>同位语从句常在句中修饰抽象的名词，因为抽象，所以才要“另一种方式来再说一遍”。</p><h2 id="形容词性从句"><a href="#形容词性从句" class="headerlink" title="形容词性从句"></a>形容词性从句</h2><p>在句子中起到形容词作用的句子，相当于一个“大形容词”。<br>对某个人或事物进行描述，修饰某一名词或代词的从句，具有形容词的性质。</p><h3 id="定语从句"><a href="#定语从句" class="headerlink" title="定语从句"></a>定语从句</h3><p>也称关系从句、形容词性从句。<br>定语从句就是修饰或限定名词和代词，作后置定语的句子。<br>定语从句一般位于被修饰的名词或代词的后面，也就是先行词的后面。<br>连接词作定语从句的主语时，其后的谓语动词的人称和数取决于先行词。</p><p>定语从句的连接词：</p><blockquote><ul><li>关系代词：who、whom、whose、which、that、as。</li><li>关系副词：when、where、why。</li></ul><p>这些关系代词和关系副词是没有意思的，只起到构成定语从句的作用，但是在定义从句中可以担任一个成分。</p></blockquote><p>关系代词：</p><blockquote><ul><li>who：指代人，在定语从句中作主语。引导的定语从句只能修饰或限定表示人的名词或代词。</li><li>whom：指代人，在定语从句中作宾语，并且可以省略。引导的定语从句只能修饰或限定表示人的名词或代词。</li><li>which：指代事物，在定语从句中作主语或宾语，作宾语时可以省略。引导的定语从句只能修饰或限定表示事物的名词或代词。</li><li>that：既可以指人也可以指物，在定语从句中作主语或宾语，作宾语时可以省略。引导的定语从句可以修饰或限定表示人或者表示事物的名词或代词。that 可以和 who 或 whom 互换使用，意思不变。但是 who 和 whom 比 that 更常用，that 一般属于非正式用法。</li><li>whose：在定语从句中作前置定语，将“whose + 名词”做为一个整体，然后在定语从句中作主语或宾语。引导的定语从句可以修饰或限定表示人或者表示事物的名词或代词。whose &#x3D; “先行词&#39;s” 的意思。</li></ul></blockquote><p>which 和 that 的区别：</p><blockquote><ul><li>which 可以引导非限定性定语从句，that 不可以。</li><li>which 前面可以加介词，that 不可以。which 在从句中所介词宾语时可以把介词放在 which 的前面。</li><li>先行词是不定代词、被序数词修饰、被形容词最高级修饰、被 the very、the only、the just 等修饰的时候，用 that 不用 which。</li><li>先行词明确唯一，没有其他可能时，用 that 不用 which。</li><li>先行词如果是多个同类事物中按限定条件选择，则不一定用 that，也可以用 which。</li></ul></blockquote><p>关系副词：</p><blockquote><ul><li>when：在定语从句中作时间状语。引导的定语从句只能修饰表示时间的名词或代词。</li><li>where：在定语从句中作地点状语。引导的定语从句只能修饰表示地点的名词或代词。</li><li>why：在定语从句中作状语。引导的定语从句只能修饰 reason 这个名词。</li></ul></blockquote><p>关系代词前面带介词的定语从句：</p><blockquote><ul><li>which 和 whom 在定语从句中作介词的宾语<ul><li>作“含介词的短语动词”的宾语</li><li>作“含介词的固定句型”的介词宾语</li><li>介词 + which&#x2F;whom 构成介词短语作定语从句的状语</li></ul></li></ul></blockquote><p>限定性和非限定性定语从句：</p><blockquote><ul><li>限定行定语从句：对先行词具有限定或修饰作用，使该词的含义更具体、更明确。限定性定语从句与先行词之间不能用逗号隔开。限定性定语从句中的关系代词在从句中作宾语时可以省略。限定性定语从句修饰的是名词或代词。</li><li>非限定性定语从句：定语从句有时跟先行词的关系并不十分密切，只是作一些附加说明，不起限定作用，这种从句称为非限定性定语从句，多用于书面语，往往用逗号与主句隔开。非限定性定语从句经常可以修饰人名或地名。which 引导的非限定性定语从句可以代表整个主句所讲的内容。</li></ul></blockquote><p>使用定语从句应注意的问题：</p><blockquote><ul><li>定语从句有时不直接紧靠着先行词，中间可能由一个定语、状语或谓语隔开。</li><li>关系代词和关系副词在从句中本身已经充当一个成分。</li></ul></blockquote><h2 id="副词性从句"><a href="#副词性从句" class="headerlink" title="副词性从句"></a>副词性从句</h2><p>在句子中起到副词作用的句子，相当于一个“大副词”。</p><h3 id="状语从句"><a href="#状语从句" class="headerlink" title="状语从句"></a>状语从句</h3><p>在复合句担任状语成分的从句。<br>状语从句的连接词是有意思的，但在状语从句中不充当任何句子成分，只起到链接的作用。</p><h4 id="时间状语从句"><a href="#时间状语从句" class="headerlink" title="时间状语从句"></a>时间状语从句</h4><p>时间状语从句的时态决定了主句的时态。<br>时间状语从句不能出现将来时态。<br>时间状语从句在复合句中可以放开头也可以放结尾，放开头需要加逗号。</p><blockquote><ul><li>when(当……的时候)：有意思，但没有作用。</li><li>whenever(无论什么时候)：用法跟 when 一样。</li><li>while(当……的时候)</li><li>as(当……的时候)</li><li>after(……之后)</li><li>before(……之前)</li><li>since(自从……)：引导的状语从句必须使用一般过去时态，构成复合句的主句必须是完成时态。</li><li>until(直到……)</li><li>as soon as(一……就)</li><li>once(一旦……)</li></ul></blockquote><p>主将从现：主句是一般将来时态，时间状语从句用一般现在时态表达将来的时间概念。</p><h4 id="地点状语从句"><a href="#地点状语从句" class="headerlink" title="地点状语从句"></a>地点状语从句</h4><p>连接副词：</p><ul><li>where(在哪里)</li><li>wherever(无论在哪里)</li><li>no matter where &#x3D; wherever</li></ul><h4 id="原因状语从句"><a href="#原因状语从句" class="headerlink" title="原因状语从句"></a>原因状语从句</h4><p>最容易的状语从句，因为构成方式非常简单，连接词直接跟一个完整的句子就可以，而且没有时态的要求。</p><p>从属连词：</p><ul><li>because(因为)：不能和 so 连用。</li><li>as(因为)：语气比 because 弱。</li><li>for(因为)：语气比 because 弱。</li><li>since(既然)</li></ul><h4 id="条件状语从句"><a href="#条件状语从句" class="headerlink" title="条件状语从句"></a>条件状语从句</h4><p>从属连词：</p><ul><li>if(如果)</li><li>unless(除非)</li><li>as long as(只要)</li></ul><p>时态的两种情况：</p><ul><li>真实的条件状语从句：跟时间状语从句一样使用主将从现的规则。</li><li>虚拟的条件状语从句：if 引导的条件状语从句可以是其他时态。</li></ul><h4 id="方式状语从句"><a href="#方式状语从句" class="headerlink" title="方式状语从句"></a>方式状语从句</h4><p>方式状语从句只能出现在表示动作的句型中。</p><ul><li>as(按照)</li><li>just as(正如)</li><li>as if(好像)：引导的方式状语从句经常使用虚拟语气。</li></ul><h4 id="让步状语从句"><a href="#让步状语从句" class="headerlink" title="让步状语从句"></a>让步状语从句</h4><ul><li>though&#x2F;although(尽管)</li><li>even if&#x2F;even though(即使)</li></ul><p>even if 引导的让步状语从句有时有主将从现的规则。</p><h4 id="目的状语从句"><a href="#目的状语从句" class="headerlink" title="目的状语从句"></a>目的状语从句</h4><ul><li>that(以便)</li><li>so that(以便)</li><li>in order that(为了)</li><li>lest(以免)</li></ul><h4 id="结果状语从句"><a href="#结果状语从句" class="headerlink" title="结果状语从句"></a>结果状语从句</h4><ul><li>so that(以至)</li><li>so……that……(如此……以至……)</li></ul><h4 id="比较状语从句"><a href="#比较状语从句" class="headerlink" title="比较状语从句"></a>比较状语从句</h4><ul><li>than(比)</li><li>as……as(和……一样)</li><li>not so……as(不如……)</li><li>less……than……(不如……)</li></ul><p>特殊结构一：</p><blockquote><p>the + 形容词比较级&#x2F;副词比较级（+ 句子），the + 另一个形容词比较级&#x2F;另一个副词比较级（+ 句子）</p><ul><li>the + 形容词比较级，the + 另一个形容词比较级<ul><li>越……，就越……。</li></ul></li><li>the + 形容词比较级 + 主语 + 系动词，the + 另一个形容词比较级 + 主语 + 系动词<ul><li>“the + 形容词比较级”相当于“主语 + 系动词”的表语。</li><li>某人或某物越……，就越……。</li></ul></li><li>the + 形容词比较级 + 名词 + 主语 + 及物动词，the + 另一个形容词比较级 + 名词 + 主语 + 及物动词<ul><li>“the + 形容词比较级 + 名词”相当于“主语 + 及物动词”的宾语。</li><li>某人越做什么事情，就越……。</li></ul></li><li>the + 方式副词比较级 + 主语 + 谓语（+ 宾语），the + 另一个方式副词比较级 + 主语 + 谓语（+ 宾语）<ul><li>“the + 方式副词比较级”相当于“主语 + 谓语（+ 宾语）”的状语</li><li>某人越……，就越……。</li></ul></li></ul></blockquote><p>特殊结构二：</p><blockquote><p>形容词比较级&#x2F;副词比较级 + and + 同一个形容词比较级&#x2F;同一个副词比较级<br>表示“越来越……”，一般作表语或状语。</p><p>作表语：</p><ul><li>主语 + 系动词 + 形容词的比较级 + and + 同一个形容词的比较级</li></ul><p>作状语：</p><ul><li>主语 + 谓语（+ 宾语）+ 方式副词比较级 + and + 同一个方式副词比较级</li></ul></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;又称主从复合句，由一个主句和一个及以上的从句构成。&lt;br&gt;从句不能独立存在，必须作整个复合句中的某个句子成分。&lt;br&gt;从句一般需要连接词引导，但有时候可能会被省略。&lt;/p&gt;</summary>
    
    
    
    <category term="学习笔记" scheme="https://lisir.me/hexo-theme-keep/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="英语语法" scheme="https://lisir.me/hexo-theme-keep/tags/%E8%8B%B1%E8%AF%AD%E8%AF%AD%E6%B3%95/"/>
    
    <category term="复合句" scheme="https://lisir.me/hexo-theme-keep/tags/%E5%A4%8D%E5%90%88%E5%8F%A5/"/>
    
  </entry>
  
  <entry>
    <title>英语语法 | 时态</title>
    <link href="https://lisir.me/hexo-theme-keep/posts/26b33495/"/>
    <id>https://lisir.me/hexo-theme-keep/posts/26b33495/</id>
    <published>2023-12-24T11:57:46.000Z</published>
    <updated>2024-09-02T06:10:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>时态是一个动作发生的时间和当时所处的状态。</p><span id="more"></span><p><img                         lazyload                       alt="image"                       data-src="https://img.lisir.me/image/posts/26b33495/20240111182918.png"                        alt="20240111182918"                 ></p><hr><h2 id="现在一般时态"><a href="#现在一般时态" class="headerlink" title="现在一般时态"></a>现在一般时态</h2><p>表示经常性、习惯性、有规律性的动作和状态。<br>表示真理性、客观性的动作和状态。<br>表示不轻易改变的状态。<br>表示此时此刻的状态。</p><blockquote><p>主语是 I 的情况用 am<br>主语是第三人称单数用 is<br>主语是复数和 you 时用 are</p></blockquote><p>表示状态的句子：</p><blockquote><ul><li>形式一<ul><li>肯定句：主语 + is&#x2F;are&#x2F;am + 表语</li><li>否定句：主语 + is&#x2F;are&#x2F;am + not + 表语</li><li>疑问句：Is&#x2F;Are&#x2F;Am + 主语 + 表语 + ？</li></ul></li><li>形式二<ul><li>肯定句：非三单 + 特殊系动词原型 + 表语</li><li>否定句：非三单 + don&#39;t + 特殊系动词原型 + 表语</li><li>疑问句：Do + 非三单 + 特殊系动词原型 + 表语 + ？</li></ul></li><li>形式三<ul><li>肯定句：三单 + 特殊系动词三单格式 + 表语</li><li>否定句：三单 + doesn&#39;t + 特殊系动词原型 + 表语</li><li>疑问句：Does + 三单 + 特殊系动词原型 + 表语 + ？</li></ul></li></ul></blockquote><p>表示动作的句子：</p><blockquote><ul><li>形式一<ul><li>肯定句：非三单&#x2F;名词复数 + 实义动词原型（+ 宾语）</li><li>否定句：非三单&#x2F;名词复数 + don&#39;t + 实义动词原型（+ 宾语）</li><li>疑问句：Do + 非三单&#x2F;名词复数 + 实义动词原型（+ 宾语）+ ？</li></ul></li><li>形式二<ul><li>肯定句：三单&#x2F;名词单数 + 实义动词三单格式（+ 宾语）</li><li>否定句：三单&#x2F;名词单数 + doesn&#39;t + 实义动词原形（+ 宾语）</li><li>疑问句：Does + 三单&#x2F;名词单数 + 实义动词原型（+ 宾语）+ ？</li></ul></li></ul></blockquote><h2 id="过去一般时态"><a href="#过去一般时态" class="headerlink" title="过去一般时态"></a>过去一般时态</h2><p>表示过去发生的动作或状态。</p><blockquote><p>主语是单数用 was<br>主语是复数或 you 时用 were</p></blockquote><p>表示状态的句子：</p><blockquote><ul><li>形式一<ul><li>肯定句：主语 + was&#x2F;were + 表语</li><li>否定句：主语 + was&#x2F;were + not + 表语</li><li>疑问句：Was&#x2F;Were + 主语 + 表语 + ？</li></ul></li><li>形式二<ul><li>肯定句：主语 + 特殊系动词过去式 + 表语</li><li>否定句：主语 + didn&#39;t + 特殊系动词原型 + 表语</li><li>疑问句：Did + 主语 + 特殊系动词原型 + 表语 + ？</li></ul></li></ul></blockquote><p>表示动作的句子：</p><blockquote><ul><li>肯定句：主语 + 实义动词过去式（+ 宾语）</li><li>否定句：主语 + didn&#39;t + 实义动词原型（+ 宾语）</li><li>疑问句：Did + 主语 + 实义动词原型（+ 宾语）+ ？</li></ul></blockquote><h2 id="将来一般时态"><a href="#将来一般时态" class="headerlink" title="将来一般时态"></a>将来一般时态</h2><p>表示即将要发生的动作和状态的，或者说这些动作和状态还没有发生，但是在将来的某个时间要发生。</p><p>表示状态的句子：</p><blockquote><ul><li>形式一<ul><li>肯定句：主语 + will + be + 表语</li><li>否定句：主语 + won&#39;t + be + 表语</li><li>疑问句：Will + 主语 + be + 表语 + ？</li></ul></li><li>形式二<ul><li>肯定句：I&#x2F;We + shall + be + 表语</li><li>否定句：I&#x2F;We + shan&#39;t + be + 表语</li><li>疑问句：Shall + I&#x2F;we + be + 表语 + ？</li></ul></li><li>形式三<ul><li>肯定句：主语 + is&#x2F;are&#x2F;am going to + be + 表语</li><li>否定句：主语 + is&#x2F;are&#x2F;am + not + going to + be + 表语</li><li>疑问句：Is&#x2F;Are&#x2F;Am + 主语 + going to + be + 表语 + ？</li></ul></li><li>形式四<ul><li>肯定句：主语 + will + 特殊系动词原型 + 表语</li><li>否定句：主语 + won&#39;t + 特殊系动词原型 + 表语</li><li>疑问句：Will + 主语 + 特殊系动词原型 + 表语 + ？</li></ul></li><li>形式五<ul><li>肯定句：主语 + is&#x2F;are&#x2F;am going to + 特殊系动词原型 + 表语</li><li>否定句：主语 + is&#x2F;are&#x2F;am + not + going to + 特殊系动词原型 + 表语</li><li>疑问句：Is&#x2F;Are&#x2F;Am + 主语 + going to + 特殊系动词原型 + 表语 + ？</li></ul></li></ul></blockquote><p>表示动作的句子：</p><blockquote><ul><li>形式一<ul><li>肯定句：主语 + will + 实义动词原型（+ 宾语）</li><li>否定句：主语 + won&#39;t + 实义动词原形（+ 宾语）</li><li>疑问句：Will + 主语 + 实义动词原形（+ 宾语）+ ？</li></ul></li><li>形式二<ul><li>肯定句：主语 + is&#x2F;are&#x2F;am going to + 实义动词原型（+ 宾语）</li><li>否定句：主语 + is&#x2F;are&#x2F;am + not + going to + 实义动词原形（+ 宾语）</li><li>疑问句：Is&#x2F;Are&#x2F;Am + 主语 + going to + 实义动词原形（+ 宾语）+ ？</li></ul></li></ul></blockquote><h2 id="过去将来一般时态"><a href="#过去将来一般时态" class="headerlink" title="过去将来一般时态"></a>过去将来一般时态</h2><p>和将来一般时态有关系。<br>表示从过去某一段时间来看将要发生的动作或者存在的状态。<br>这个时态基本上用在宾语从句里面。</p><p>表示动作的句子：</p><blockquote><ul><li>形式一<ul><li>肯定句：主语 + would + 实义动词原形（+ 宾语）</li><li>否定句：主语 + would + not + 实义动词原形（+ 宾语）</li></ul></li><li>形式二<ul><li>肯定句：主语 + was&#x2F;were + going to + 实义动词原形（+ 宾语）</li><li>否定句：主语 + was&#x2F;were + not + going to 实义动词原形（+ 宾语）</li></ul></li></ul></blockquote><p>表示状态的句子：</p><blockquote><ul><li>形式一<ul><li>肯定句：主语 + would + be + 表语</li><li>否定句：主语 + would + not + be + 表语</li></ul></li><li>形式二<ul><li>肯定句：主语 + was&#x2F;were + going to + be + 表语</li><li>否定句：主语 + was&#x2F;were + not + going to + be + 表语</li></ul></li></ul></blockquote><h2 id="现在完成时态"><a href="#现在完成时态" class="headerlink" title="现在完成时态"></a>现在完成时态</h2><p>表示从过去某时开始一直延续到现在的动作和状态。<br>表示过去发生的某一动作对现在造成的影响和结果。</p><p>表示状态的句子：</p><blockquote><ul><li>肯定句：主语 + have&#x2F;has + been + 表语</li><li>否定句：主语 + haven&#39;t&#x2F;hasn&#39;t + been + 表语</li><li>疑问句：Have&#x2F;Has + 主语 + been + 表语 + ？</li></ul></blockquote><p>表示动作的句子：</p><blockquote><ul><li>形式一<ul><li>肯定句：非三单&#x2F;名词复数 + have + 实义动词过去分词（+ 宾语）</li><li>否定句：非三单&#x2F;名词复数 + haven&#39;t + 实义动词过去分词（+ 宾语）</li><li>疑问句：Have + 非三单&#x2F;名词复数 + 实义动词过去分词（+ 宾语）+ ？</li></ul></li><li>形式二<ul><li>肯定句：三单&#x2F;名词单数 + has + 实义动词过去分词（+ 宾语）</li><li>否定句：三单&#x2F;名词单数 + hasn&#39;t + 实义动词过去分词（+ 宾语）</li><li>疑问句：Has + 三单&#x2F;名词单数 + 实义动词过去分词（+ 宾语）+ ？</li></ul></li></ul></blockquote><h2 id="过去完成时态"><a href="#过去完成时态" class="headerlink" title="过去完成时态"></a>过去完成时态</h2><p>和现在完成时态有关系。<br>表示过去某个时间或某个动作之前已经完成的动作，<br>或者表示从过去某个时间开始一直延续到过去一个时间的动作。</p><p>表示状态的句子：</p><blockquote><ul><li>肯定句：主语 + had + been + 表语</li><li>否定句：主语 + hadn&#39;t + been + 表语</li><li>疑问句：Had + 主语 + been + 表语</li></ul></blockquote><p>表示动作的句子：</p><blockquote><ul><li>肯定句：主语 + had + 实义动词过去分词 （+ 宾语）</li><li>否定句：主语 + hadn&#39;t + 实义动词过去分词 （+ 宾语）</li><li>疑问句：Had + 主语 + 实义动词过去分词（+ 宾语）</li></ul></blockquote><h2 id="现在进行时态"><a href="#现在进行时态" class="headerlink" title="现在进行时态"></a>现在进行时态</h2><p>表示主语此时此刻正在进行的动作。</p><p>表示状态的句子：</p><blockquote><ul><li>肯定句：主语 + is&#x2F;are&#x2F;am + 特殊系动词现在分词 + 表语</li><li>否定句：主语 + is&#x2F;are&#x2F;am + not + 特殊系动词现在分词 + 表语</li><li>疑问句：Is&#x2F;Are&#x2F;Am + 主语 + 特殊系动词现在分词 + 表语 + ？</li></ul></blockquote><p>表示动作的句子：</p><blockquote><ul><li>肯定句：主语 + is&#x2F;are&#x2F;am + 实义动词现在分词（+ 宾语）</li><li>否定句：主语 + is&#x2F;are&#x2F;am + not + 实义动词现在分词（+ 宾语）</li><li>疑问句：Is&#x2F;Are&#x2F;Am + 主语 + 实义动词现在分词（+ 宾语）+ ？</li></ul></blockquote><h2 id="过去进行时态"><a href="#过去进行时态" class="headerlink" title="过去进行时态"></a>过去进行时态</h2><p>和现在进行时态有关系。<br>表示过去某一时刻或某段时间内正在进行的动作。<br>过去进行时态的时间状语一般由时间状语从句或一些表达过去某一刻的的词语充当。<br>也可以使用两个时间来构成时间状语。</p><blockquote><p>was 用于第一人称单数和第三人称单数<br>were 用于其他各种人称</p></blockquote><p>表示动作的句子：</p><blockquote><ul><li>肯定句：主语 + was&#x2F;were + 实义动词现在分词（+ 宾语）</li><li>否定句：主语 + was&#x2F;were + not + 实义动词现在分词（+ 宾语）</li><li>疑问句：Was&#x2F;Were + 主语 + 实义动词现在分词（+ 宾语）</li></ul></blockquote><h2 id="现在完成进行时态"><a href="#现在完成进行时态" class="headerlink" title="现在完成进行时态"></a>现在完成进行时态</h2><p>和现在完成时态、现在进行时态有关系。</p><p>表示动作的句子：</p><blockquote><ul><li>肯定句：主语 + have&#x2F;has + been + 实义动词现在分词（+ 宾语）</li><li>否定句：主语 + haven&#39;t&#x2F;hasn&#39;t + been + 实义动词现在分词（+ 宾语）</li><li>疑问句：Have&#x2F;Has + 主语 + been + 实义动词现在分词（+ 宾语）</li></ul></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;时态是一个动作发生的时间和当时所处的状态。&lt;/p&gt;</summary>
    
    
    
    <category term="学习笔记" scheme="https://lisir.me/hexo-theme-keep/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="英语语法" scheme="https://lisir.me/hexo-theme-keep/tags/%E8%8B%B1%E8%AF%AD%E8%AF%AD%E6%B3%95/"/>
    
    <category term="时态" scheme="https://lisir.me/hexo-theme-keep/tags/%E6%97%B6%E6%80%81/"/>
    
  </entry>
  
  <entry>
    <title>英语语法 | 简单句</title>
    <link href="https://lisir.me/hexo-theme-keep/posts/84c90a91/"/>
    <id>https://lisir.me/hexo-theme-keep/posts/84c90a91/</id>
    <published>2023-12-24T11:57:46.000Z</published>
    <updated>2024-10-04T12:26:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>由词语或者短语构成各个句子成分的句子。</p><span id="more"></span><hr><h2 id="基本句型"><a href="#基本句型" class="headerlink" title="基本句型"></a>基本句型</h2><p>英语中的五种基本句型结构</p><ul><li>状态型<ul><li>主系表</li></ul></li><li>动作型<ul><li>主谓</li><li>主谓宾</li><li>主谓双宾</li><li>主谓宾宾补</li></ul></li></ul><h3 id="状态型"><a href="#状态型" class="headerlink" title="状态型"></a>状态型</h3><p>主系表结构，表示状态的句型，不能出现实义动词。</p><p>主系表：</p><blockquote><ul><li>主语 + be 系动词 + 表语<ul><li>I am happy every day（我每天都很开心）</li></ul></li><li>主语 + 特殊系动词 + 表语<ul><li>He looks good（他看起来不错）</li></ul></li></ul></blockquote><h3 id="动作型"><a href="#动作型" class="headerlink" title="动作型"></a>动作型</h3><p>主谓宾结构，表示动作的句型，不能出现系动词。</p><p>主谓：</p><blockquote><ul><li>主语 + 不及物动词<ul><li>I work here（我在这里上班）</li></ul></li></ul></blockquote><p>主谓宾：</p><blockquote><ul><li>主语 + 及物动词 + 宾语<ul><li>I study English at home（我在家里学英语）</li></ul></li></ul></blockquote><p>主谓双宾：</p><blockquote><ul><li>主语 + 双宾动词 + 双宾语<ul><li>I give her an apple every day（我每天给她一个苹果）</li></ul></li></ul></blockquote><p>主谓宾宾补：</p><blockquote><ul><li>主语 + 特定及物动词 + 宾语 + 宾补<ul><li>I make her happy every day（我每天都让她开心）</li></ul></li></ul></blockquote><h2 id="特殊句型"><a href="#特殊句型" class="headerlink" title="特殊句型"></a>特殊句型</h2><h3 id="There-be"><a href="#There-be" class="headerlink" title="There be"></a>There be</h3><p>there be 后面的名词是句子的主语，属倒装结构（完全倒装句）。<br>疑问句形式是将 be 或助动词、情态动词提至 there 之前。<br>否定形式则直接在 be 或助动词、情态动词后加 not。</p><blockquote><p>就近原则：多个主语时，be 系动词用哪个格式取决于靠它近的主语。</p></blockquote><p>there be 的基本句型：</p><blockquote><ul><li>肯定句：There + is&#x2F;are + 主语 + 状语</li><li>否定句：There + is&#x2F;are + not&#x2F;no + 主语 + 状语</li><li>疑问句：Is&#x2F;Are + there + 主语 + 状语 + ？</li></ul></blockquote><p>含 there be 的特殊疑问句：</p><blockquote><ul><li>疑问词 + 名词 + there be + 状语 + ？</li></ul></blockquote><p>there be 句型的时态变化：</p><blockquote><ul><li>一般现在时态：There is&#x2F;are + 主语 + 状语</li><li>一般过去时态：There was&#x2F;were + 主语 + 状语</li><li>一般将来时态：There will be + 主语 + 状语</li><li>现在完成时态：There has&#x2F;have been + 主语 + 状语</li></ul></blockquote><p>含有情态动词的 there be 句型：</p><blockquote><ul><li>There 情态动词 be + 主语 + 状语</li></ul></blockquote><p>have 和 there be 的用法和区别：</p><blockquote><ul><li>there be 表示存在，have 表示拥有、持有。</li><li>have 有时候还表示包括、包含的意思，这个时候它们可以互换使用。</li><li>用 have 侧重主观存在，用 there be 侧重客观存在。</li></ul></blockquote><p>there be 结构出现主补的情况：</p><blockquote><ul><li>There be + 主语 + 动名词&#x2F;动词不定式&#x2F;过去分词 + 状语</li></ul><p>主语后面的动名词、动词不定式和过去分词起到补充说明的作用，所以称为主补。</p></blockquote><h3 id="特殊疑问句"><a href="#特殊疑问句" class="headerlink" title="特殊疑问句"></a>特殊疑问句</h3><p>特殊疑问句的构成方式：</p><blockquote><ul><li>疑问词 + 一般疑问句 + ？</li></ul></blockquote><p>特殊疑问词：</p><blockquote><ul><li>where(在哪里)：在特殊疑问句中作地点状语、表语、介词宾语和宾补。</li><li>what(什么)：在特殊疑问句中作宾语、表语和主语，也可以作定语，后面跟一个名词作构成复合疑问词。</li><li>why(为什么)：在特殊疑问句中主要作原因状语，偶尔可以在主谓宾结构中作主语。</li><li>whose(谁的)：在特殊疑问句中作定语和表语，后面跟名词之后可以作宾语和表语。</li><li>which(哪一个)：在特殊疑问句中作定语，后面跟名词之后可以作宾语。</li><li>when(什么时候)：在特殊疑问句中作时间状语和表语，跟 what time 是同义词，一般可以互换。</li><li>how(如何、怎样)：在特殊疑问句中作表语和方式状语，后跟形容词或副词可以构成很多新的复合疑问词。</li><li>whom(谁)：在特殊疑问句中只能作宾语。</li><li>who(谁)：在特殊疑问句中作主语。</li></ul></blockquote><p>疑问词作主语时的句型：</p><blockquote><p>不需要倒装，因为本来主语就是放在开头。</p><ul><li>疑问词 + 谓语 + 宾语 + ？</li><li>疑问词 + be + 表语 + ？</li></ul></blockquote><p>能作主语的疑问词有：</p><blockquote><ul><li>which + 名词单数</li><li>whose + 名词</li><li>how many + 名词复数</li><li>how much + 不可数名词</li><li>what + 名词</li><li>what</li><li>who</li></ul></blockquote><h3 id="被动句"><a href="#被动句" class="headerlink" title="被动句"></a>被动句</h3><p>被动句属于动作型的句子。</p><ul><li><a href="/hexo-theme-keep/posts/9e47et28/#%E8%A2%AB%E5%8A%A8%E8%AF%AD%E6%80%81">被动语态</a></li></ul><h3 id="感叹句"><a href="#感叹句" class="headerlink" title="感叹句"></a>感叹句</h3><p>以 what 或 how 开头的句子。</p><ul><li>What + a&#x2F;an + 形容词 + 可数名词单数 + 主语 + be<ul><li>What a beautiful wife he has!</li></ul></li><li>How + 形容词 + 主语 + 系动词<ul><li>How free you are!</li></ul></li><li>How + 方式副词 + 主语 + 谓语 + 宾语<ul><li>How loudly you sing songs!</li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;由词语或者短语构成各个句子成分的句子。&lt;/p&gt;</summary>
    
    
    
    <category term="学习笔记" scheme="https://lisir.me/hexo-theme-keep/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="英语语法" scheme="https://lisir.me/hexo-theme-keep/tags/%E8%8B%B1%E8%AF%AD%E8%AF%AD%E6%B3%95/"/>
    
    <category term="简单句" scheme="https://lisir.me/hexo-theme-keep/tags/%E7%AE%80%E5%8D%95%E5%8F%A5/"/>
    
  </entry>
  
  <entry>
    <title>英语语法 | 词性</title>
    <link href="https://lisir.me/hexo-theme-keep/posts/78cf5cff/"/>
    <id>https://lisir.me/hexo-theme-keep/posts/78cf5cff/</id>
    <published>2023-12-24T11:57:46.000Z</published>
    <updated>2024-09-02T06:10:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>英语十大词性：</p><table><thead><tr><th>中文名称</th><th>英文名称</th><th>简写</th><th>例子</th></tr></thead><tbody><tr><td>名词</td><td>noun</td><td>n.</td><td>student（学生）</td></tr><tr><td>代词</td><td>pronoun</td><td>pron.</td><td>you（你）</td></tr><tr><td>形容词</td><td>adjective</td><td>adj.</td><td>happy（高兴）</td></tr><tr><td>副词</td><td>adverb</td><td>adv.</td><td>quickly（迅速地）</td></tr><tr><td>动词</td><td>verb</td><td>v.</td><td>cut（砍、割）</td></tr><tr><td>及物动词</td><td>transitive verb</td><td>vt.</td><td>buy（买）</td></tr><tr><td>不及物动词</td><td>intransitive verb</td><td>vi.</td><td>cry（哭）</td></tr><tr><td>数词</td><td>numeral</td><td>num.</td><td>three（三）</td></tr><tr><td>冠词</td><td>article</td><td>art.</td><td>a（一个）</td></tr><tr><td>介词</td><td>preposition</td><td>prep.</td><td>at（在……）</td></tr><tr><td>连词</td><td>conjunction</td><td>conj.</td><td>and（和）</td></tr><tr><td>感叹词</td><td>interjection</td><td>interj.</td><td>oh（哦）</td></tr></tbody></table><span id="more"></span><hr><h2 id="名词"><a href="#名词" class="headerlink" title="名词"></a>名词</h2><p>世间万物的名称。</p><h3 id="普通名词"><a href="#普通名词" class="headerlink" title="普通名词"></a>普通名词</h3><p>指称人或事物的总类的名词。</p><h4 id="可数名词"><a href="#可数名词" class="headerlink" title="可数名词"></a>可数名词</h4><p>肉眼能分清数量的名词。<br>一个可数名词的单数是不能单独在句子或短语里出现的，需要加限定词或加冠词，或变复数。<br>限定词有形容词性物主代词、指示代词、有生命的名词所有格、数词等。</p><p>单数变复数的规则：</p><blockquote><ul><li>以元音字母 + o 或 y 结尾的直接 + s</li><li>以 s、x、ch、sh 结尾的直接 + es</li><li>以辅音字母 + o 结尾的直接 + es</li><li>以辅音字母 + y 结尾的将 y 改为 i 再 + es</li><li>以 f 或 fe 结尾的将 f 或 fe 改为 v 再 + es</li></ul></blockquote><h4 id="不可数名词"><a href="#不可数名词" class="headerlink" title="不可数名词"></a>不可数名词</h4><p>肉眼分不清数量的名词。<br>不可数名词没有复数的格式，只有单数的格式。<br>不可数名词属于单数概念，作主语时后面的谓语动词要考虑变单数格式。</p><h4 id="复数名词"><a href="#复数名词" class="headerlink" title="复数名词"></a>复数名词</h4><p>只有复数的形式，没有单数的形式。比如：</p><blockquote><ul><li>people（人们）、police（警察）。</li></ul></blockquote><h3 id="专有名词"><a href="#专有名词" class="headerlink" title="专有名词"></a>专有名词</h3><p>人名、地名、国家名、景观名。</p><h3 id="复合名词"><a href="#复合名词" class="headerlink" title="复合名词"></a>复合名词</h3><p>名词作前置定语可以看作是复合名词。<br>复合名词是由两个或两个以上的词组成的名词，它们作为一个单位共同确定一个人、地方或事物。</p><p>复合名词通常由两个名词或一个形容词和一个名词组成。比如：</p><blockquote><ul><li>English book（英语书）、peanut oil（花生油）、chicken paw（鸡爪）。</li></ul></blockquote><p>判断一个复合名词是可数或不可数，取决于后面那个名词。比如：</p><blockquote><ul><li>English book 中的 book 是可数的，所以这个复合名词就是可数的。</li><li>peanut oil 中的 oil 是不可数的，所以这个复合名词就是不可数的。</li></ul></blockquote><p>复合名词中，前面的那个名词即使是可数名词，也不能是复数形式。比如：</p><blockquote><ul><li>chicken paw 中的 chicken 只能是单数形式。</li></ul></blockquote><h3 id="名词短语"><a href="#名词短语" class="headerlink" title="名词短语"></a>名词短语</h3><p>前置定语加名词或者名词加后置定语。</p><h3 id="所有格"><a href="#所有格" class="headerlink" title="所有格"></a>所有格</h3><p>所有格就是所有者与所有物的所属关系。</p><h4 id="名词所有格"><a href="#名词所有格" class="headerlink" title="名词所有格"></a>名词所有格</h4><p>名词所有格是表示所属关系的一种格式。<br>所有格与名词连用，即表示一个物体与另一物体的从属关系。</p><blockquote><ul><li>有生命的名词 + &#39;s<ul><li>Nice&#39;s school bag（Nice 的书包）名词所有格 Nice&#39;s 作前置定语。</li><li>my friend&#39;s book（我朋友的书）名词所有格 my friend&#39;s 作前置定语。</li></ul></li><li>of + 无生命的名词<ul><li>the price of oil（油的价格）名词所有格 of oil 作后置定语。</li><li>the color of the house（这个房子的颜色）名词所有格 of the house 作后置定语。</li></ul></li></ul></blockquote><p>注意：</p><blockquote><p>有生命的名词不是以 s 结尾的加 <code>&#39;s</code>，以 s 结尾的只需要加 <code>&#39;</code>。</p></blockquote><h4 id="双重所有格"><a href="#双重所有格" class="headerlink" title="双重所有格"></a>双重所有格</h4><p>双重所有格是由无生命的名词所有格与有生命的名词所有格共同构成的。<br>双重所有格主要作后置定语，修饰一个普通名词，<em><strong>表示全体中的一部分</strong></em>。<br>双重所有格有时候也可以加强语气或表示某种感情色彩。<br>双重所有格的使用主要是为了避免名词重复。</p><blockquote><ul><li>of + 有生命的名词 + &#39;s<ul><li>three books of my friend&#39;s（我朋友的其中三本书）</li><li>a student of Nick&#39;s（Nick 的其中一个学生）</li></ul></li><li>of + 名词性物主代词<ul><li>three books of mine（我的其中三本书）</li><li>a friend of mine（我的其中一个朋友）</li></ul></li></ul></blockquote><h2 id="代词"><a href="#代词" class="headerlink" title="代词"></a>代词</h2><p>为了避免重复而代替名词的词语（生活中使用代词的频率非常高）。</p><h3 id="人称代词"><a href="#人称代词" class="headerlink" title="人称代词"></a>人称代词</h3><p>代替人的代词就叫人称代词，有些人称代词也可以指代事物。<br>人称代词的主格只能作主语，宾格只能作宾语，都能作表语。</p><h4 id="主格"><a href="#主格" class="headerlink" title="主格"></a>主格</h4><p>作主语的格式。人称代词主格有：</p><blockquote><ul><li>I（我）、we（我们）、you（你&#x2F;你们）。</li><li>she（她）、he（他）、it（它）、they（他们&#x2F;她们&#x2F;它们）。</li></ul></blockquote><p>两个或者两个以上的人称代词主格作并列主语的时候，顺序为：</p><blockquote><ul><li>单数：you &gt; he(she) &gt; I</li><li>复数：we &gt; you &gt; they</li></ul></blockquote><h4 id="宾格"><a href="#宾格" class="headerlink" title="宾格"></a>宾格</h4><p>作宾语的格式。人称代词宾格有：</p><blockquote><ul><li>me（我）、us（我们）、you（你&#x2F;你们）。</li><li>her（她）、him（他）、it（它）、them（他们&#x2F;她们&#x2F;它们）。</li></ul></blockquote><h3 id="物主代词"><a href="#物主代词" class="headerlink" title="物主代词"></a>物主代词</h3><p>表示所有关系的代词叫作物主代词。</p><h4 id="形容词性"><a href="#形容词性" class="headerlink" title="形容词性"></a>形容词性</h4><p>置于名词前，起修饰作用，表示某人的。<br>具有形容词的特性，常放在名词前面作定语（前置定语）。比如：</p><blockquote><ul><li>my book（我的书）、our house（我们的房子）。</li></ul></blockquote><h4 id="名词性"><a href="#名词性" class="headerlink" title="名词性"></a>名词性</h4><p><em><strong>名词性物主代词 &#x3D; 形容词性物主代词 + 名词</strong></em><br>名词性物主代词就相当于一个名词，所以可以作主语、表语或者宾语等，<br>但是只能在前面提到或者避免重复的时候才能用。<br>在物体已经指出的情况下而用来代替已知物体的物主代词，后面不需要加上已知名词。比如：</p><blockquote><ul><li>Your book is more expensive than mine（你的书比我的贵）其中 mine 就是表示 my book。</li></ul></blockquote><h3 id="指示代词"><a href="#指示代词" class="headerlink" title="指示代词"></a>指示代词</h3><p>this（这个）和 that（那个）修饰或限定可数名词的单数和不可数名词，不能修饰可数名词的复数。<br>these（这些）和 those（那些）只能修饰或限定可数名词的复数。</p><p>such（这样的、如此的）在句子中作主语和前置定语。<br>such 可以修饰复数名词，也可以修饰不可数名词。<br>当 such 做前置定语时，如果修饰的名词前面有不定冠词 a&#x2F;an 则将不定冠词放在 such 后面。</p><blockquote><ul><li>such was the story（故事就是这样）实际上 such 是表语，倒装句变成主语。</li><li>such a beautiful girl（如此漂亮的女孩）</li></ul></blockquote><p>same（同样的）在句子中作主语、表语、宾语、前置定语。<br>same 前面一定要加定冠词 the。<br>same 作前置定语的情况最多，而且多数修饰可数名词单数。</p><blockquote><ul><li>the same place（同一个地方）</li><li>the same school（同一所学校）</li></ul></blockquote><h3 id="不定代词"><a href="#不定代词" class="headerlink" title="不定代词"></a>不定代词</h3><p>不指明代替任何特定名词或形容词的代词叫不定代词。<br>不定代词具有名词和形容词的性质，并有可数和不可数之分。<br>在句子中可以作主语、表语、宾语、同位语、定语和状语。<br>如果有不定代词修饰可数名词，则可数名词前不能有冠词。</p><p>常见的不定代词有：</p><table><thead><tr><th>①</th><th>②</th><th>③</th></tr></thead><tbody><tr><td>some（一些）</td><td>each（每个）</td><td>all（全部）</td></tr><tr><td>any（任何）</td><td>every（每个）</td><td>more（更多）</td></tr><tr><td>both（两者都）</td><td>many（很多）</td><td>one（某人&#x2F;物）</td></tr><tr><td>none（没有人&#x2F;物）</td><td>much（很多）</td><td>few（极少数）</td></tr><tr><td>either（两者之一）</td><td>another（另一个）</td><td>little（极少量）</td></tr><tr><td>neither（两者都不）</td><td>other（别的&#x2F;其他）</td><td>no（没有）</td></tr></tbody></table><h3 id="反身代词"><a href="#反身代词" class="headerlink" title="反身代词"></a>反身代词</h3><p>表示“某某自己”的代词叫反身代词，一般只作宾语、介词宾语、表语、同位语，不能作主语。</p><blockquote><ul><li>第一、二人称<ul><li>形容词性物主代词 + self&#x2F;selves</li></ul></li><li>第三人称<ul><li>人称代词宾格 + self&#x2F;selves</li></ul></li></ul></blockquote><table><thead><tr><th></th><th>单数</th><th>复数</th></tr></thead><tbody><tr><td>第一人称</td><td>myself（我自己）</td><td>ourselves（我们自己）</td></tr><tr><td>第二人称</td><td>yourself（你自己）</td><td>yourselves（你们自己）</td></tr><tr><td>第三人称</td><td>himself（他自己） <br> herself（她自己） <br> itself（它自己）</td><td>themselves（他们&#x2F;她们&#x2F;它们自己）</td></tr></tbody></table><h3 id="相互代词"><a href="#相互代词" class="headerlink" title="相互代词"></a>相互代词</h3><p>表示相互关系的代词叫相互代词，一般只作宾语、介词宾语，其所有格形式作前置定语。</p><blockquote><ul><li>each other（两者之间）</li><li>one another（三者及以上）</li></ul></blockquote><h2 id="形容词"><a href="#形容词" class="headerlink" title="形容词"></a>形容词</h2><p>形容词一般只可以作前置定语、表语和宾补。<br>主要用来修饰名词或代词，表示人或事物的性质、状态和特征的程度好坏与否。</p><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><blockquote><ul><li>普通形容词<ul><li>单独一个单词的形容词。</li></ul></li><li>复合形容词<ul><li>两个或多个单词一起构成一个新的形容词词性的复合词。</li><li>复合形容词不能自己随意组合。</li><li>一般复合形容词中的每个单词使用减号（-）连接。</li></ul></li></ul></blockquote><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>作表语：</p><blockquote><ul><li>可以直接构成一个句型。<ul><li>You are rich（你是有钱的）形容词 rich 作表语。</li></ul></li></ul></blockquote><p>作前置定语：</p><blockquote><ul><li>不能直接造句，只能修饰一个普通名词，且只和名词有关系，放在名词前面构成短语。<ul><li>busy people（忙碌的人们）形容词 busy 作前置定语修饰名词 people。</li></ul></li><li>冠词不属于形容词，但是永远要放在作前置定语的形容词前面。<ul><li>She is my kind teacher（她是我善良的老师）冠词 my 一定放在形容词 kind 前面。</li></ul></li><li>两个或者两个以上形容词作前置定语时，顺序为：<ul><li>描绘性的形容词、表示形状的形容词、表示年龄或者新旧的形容词、<br>表示颜色的形容词、表示来源出处的形容词、表示材料物质的形容词、表示用途的形容词。</li></ul></li><li>形容词之间使用 and 连接，可以不用考虑顺序。</li></ul></blockquote><p>作宾补：</p><blockquote><ul><li>只有特定的及物动词后面才可以跟形容词作宾补。比如：<ul><li>I make you rich（我让你有钱）中 make 是一个特定的及物动词，rich 作宾补。</li></ul></li></ul></blockquote><h3 id="形式"><a href="#形式" class="headerlink" title="形式"></a>形式</h3><p>大部分的形容词都有三种形式：原级、比较级、最高级。<br>比较级相当于中文里的更的意思，最高级相当于最的意思。比如：</p><blockquote><p>原级 beautiful（漂亮的）、比较级 more beautiful（更漂亮）、最高级 most beautiful（最漂亮）。</p></blockquote><p>变化规则：</p><blockquote><ul><li>单音节形容词：比较级&#x3D;原级+er；最高级&#x3D;原级+est</li><li>以 y 和 ow 结尾的双音节形容词：比较级&#x3D;原级+er；最高级&#x3D;原级+est</li><li>三音节或多于三音节的形容词：比较级&#x3D;more+原级；最高级&#x3D;most+原级</li><li>其他双音节形容词：两种形式均适用</li><li>不规则形式：有少数形容词的比较级和最高级是不规则的</li></ul></blockquote><p>用法：</p><blockquote><ul><li>形容词的比较级和最高级跟形容词的原级一样，可以作前置定语和表语，甚至宾补。比如：<ul><li>I have a better way（我有一个更好的办法）形容词比较级 better 作前置定语。</li><li>She is my best friend（她是我最好的朋友）形容词最高级 best 作前置定语。</li></ul></li></ul></blockquote><p>句型：</p><blockquote><ul><li>A 超过 B：<ul><li>A + be + 形容词比较级 + than + B</li><li>I am taller than him（我比他高）。</li><li>My book is cheaper than yours（我的书比你的便宜）。</li></ul></li><li>A 不如 B：<ul><li>A + be not + 形容词比较级 + than + B</li><li>I am not taller than him（我没有他高）。</li><li>My girlfriend is not more beautiful than her（我女朋友没有她漂亮）。</li></ul></li><li>A 和 B 一样：<ul><li>A + be + as + 形容词原级 + as + B</li><li>I am as tall as him（我和他一样高）。</li><li>My girlfriend is as beautiful as her（我女朋友和她一样漂亮）。</li></ul></li><li>A 是最什么的：<ul><li>A + be + the + 形容词最高级 + 表示范围的词语</li><li>He is the richest in China（他是中国最有钱的）。</li></ul></li></ul></blockquote><h2 id="动词"><a href="#动词" class="headerlink" title="动词"></a>动词</h2><p>表示动作或者心理行为（活动）的词语。比如：</p><blockquote><ul><li>动作：eat（吃）、drink（喝）、play（玩）、buy（买）。</li><li>心理行为：think（思考）、like（喜欢）、know（知道）。</li></ul></blockquote><h3 id="谓语动词"><a href="#谓语动词" class="headerlink" title="谓语动词"></a>谓语动词</h3><p>专门充当谓语的动词，谓语动词只能作谓语。<br>谓语动词主要由实义动词充当。</p><h4 id="系动词"><a href="#系动词" class="headerlink" title="系动词"></a>系动词</h4><p>也称连系动词。<br>只有一个作用，就是跟表语构成系表结构作状态型谓语。<br>系动词是不能单独使用的，必须跟表语一起用。</p><p>be 系动词：</p><blockquote><p>主语决定使用哪个 be 系动词。</p><ul><li>现在一般时态<ul><li>am：主语是 I 的情况用 am</li><li>is：主语是第三人称单数用 is</li><li>are：主语是复数和 you 时用 are</li></ul></li><li>过去一般时态<ul><li>was：主语是单数用 was</li><li>were：主语是复数和 you 时用 were</li></ul></li><li>been：过去分词用 been</li><li>being：现在分词用 being</li><li>be：用于动词不定式或者放在情态动词、助动词后</li></ul></blockquote><p>特殊系动词：</p><blockquote><ul><li>特殊系动词后面必须跟形容词作表语。</li><li>是从实义动词借过来作系动词，意思会发生变化。比如：<ul><li>You look beautiful（你看起来很漂亮）中 look 作系动词，形容词 beautiful 作表语。</li></ul></li></ul></blockquote><h4 id="助动词"><a href="#助动词" class="headerlink" title="助动词"></a>助动词</h4><p>助动词是没有意思的，不能单独使用。<br>它的作用就是帮助实义动词或系动词构成复合谓语，<br>或者构成疑问句、否定句以及成为各种时态、语态和语气。<br>英语没有专门的助动词。</p><blockquote><ul><li>be</li><li>do&#x2F;did&#x2F;does</li><li>have&#x2F;has&#x2F;had</li><li>will</li><li>would</li><li>shall</li><li>should</li></ul></blockquote><h4 id="实义动词"><a href="#实义动词" class="headerlink" title="实义动词"></a>实义动词</h4><p>表示有实际意义的动词，用来区别系动词、助动词和情态动词。</p><p>变化规则：</p><blockquote><p>实义动词五种形式都是同一个意思。<br>过去式、过去分词、现在分词和第三人称单数格式都是通过原型变化而成的。</p><ul><li>变过去式和过去分词在原型后面 + ed<ul><li>词尾是 e 的动词 + d</li><li>词尾只有一个辅音字母的重读闭音节的动词先双写这个辅音字母再 + ed</li><li>词尾是辅音字母 + y 的动词改 y 为 i 再 + ed</li></ul></li><li>变现在分词在原型后面 + ing<ul><li>以不发音的 e 结尾的动词去掉 e 再 + ing</li><li>以一个辅音字母结尾的重读闭音节的动词先双写此辅音字母再 + ing</li><li>以 ie 结尾的动词把 ie 变为 ying</li></ul></li><li>变第三人称单数格式在原型后面 + s<ul><li>以 s、x、o、ch、sh 结尾的动词 + es</li><li>以辅音字母 + y 结尾的动词变 y 为 i 再 + es</li></ul></li></ul></blockquote><p>及物动词：</p><blockquote><ul><li>双宾动词（可以有两个宾语的动词）也属于及物动词。</li><li>及物动词后面一定要跟一个动作的对象或者承受者，也就是宾语。比如：<ul><li>buy 就是一个典型的需要加宾语的动词，buy 这个动作需要有一个承受者，不然意思不完整。</li></ul></li></ul></blockquote><p>不及物动词：</p><blockquote><ul><li>本身意义完整，后面不需要加宾语且不能加宾语，但是可以加状语。比如：<ul><li>sleep（睡觉）、work（工作）。</li></ul></li></ul></blockquote><h4 id="情态动词"><a href="#情态动词" class="headerlink" title="情态动词"></a>情态动词</h4><p>情态动词主要的作用就是加上动词原型构成复合谓语。<br>情态动词本身有意义，但是不完整，必须跟实义动词原形或者系动词原型构成复合谓语，<br>一般不能跟助动词连用，但是特殊的情态动词需要助动词构成时态。</p><h4 id="复合动词"><a href="#复合动词" class="headerlink" title="复合动词"></a>复合动词</h4><p>复合动词也称短语动词，和实义动词一样分及物和不及物，<br>由动词和另一个或几个单词构成的词组，实际上只表示一个动作，相当于一个动词的作用。比如：</p><blockquote><ul><li>look after（照顾）、look forward to（盼望）、look at（看）、get up（起床）。</li></ul></blockquote><h3 id="非谓语动词"><a href="#非谓语动词" class="headerlink" title="非谓语动词"></a>非谓语动词</h3><p>充当除了谓语以外的其他句子成分。<br>一个动作作主语的时候，这个表示动作的动词就要变成非谓语形式（动词不定式或者动名词）才可以作主语。</p><h4 id="动词不定式"><a href="#动词不定式" class="headerlink" title="动词不定式"></a>动词不定式</h4><p>动词不定式没有人称和数的变化，不受主语人称和谓语动词的时态变化干扰。<br>动词不定式是动词的一种非谓语形式，是由 to + 动词原形构成。<br>to 只是一个构成动词不定式的一个符号，本身没有意思，是用来区别谓语动词的标志。<br>动词不定式就是为了让动词能作其他句子成分的一种方式。</p><blockquote><ul><li>To eat is important（吃很重要）动词不定式 to eat 作主语。</li></ul></blockquote><p>动词不定式可以有自己的宾语和状语，同它的宾语或者状语构成动词不定式短语。<br>动词不定式短语是单数概念。</p><blockquote><ul><li>To learn English is easy（学英语很容易）动词不定式短语 to learn 和动词不定式的宾语 English 作主语。</li><li>To be rich is a happy thing（有钱是一件快乐的事情）动词不定式短语 to be rich 作主语。</li><li>I hope to be happy（我希望快乐）动词不定式短语 to be happy 作宾语。</li></ul></blockquote><h4 id="动名词"><a href="#动名词" class="headerlink" title="动名词"></a>动名词</h4><p>动名词短语是单数概念。</p><blockquote><ul><li>Eating is important（吃很重要）动名词 eating 作主语。</li><li>Learning English is funny（学英语是有趣的）动名词 learning 和动名词的宾语 English 作主语。</li></ul></blockquote><p>动名词与不定式的区别：</p><blockquote><ul><li>动名词表达的是： 状态，性质，心境，抽象，经常性，已发生的</li><li>不定式表达的是： 目的，结果，原因，具体，一次性，将发生的</li></ul></blockquote><p>动名词与不定式暗含的时间含义：</p><blockquote><ul><li>动名词有正在做、习惯性做的时间含义。</li><li>不定式有还没有做、将要去做的时间含义。</li></ul></blockquote><h4 id="过去分词"><a href="#过去分词" class="headerlink" title="过去分词"></a>过去分词</h4><p>过去分词就是一种动词形式。<br>作谓语动词时不能单独使用，必须跟助动词构成复合谓语，主要用在现在完成时态和被动语态中。<br>作非谓语动词的时候一般表示已经完成或被动意义，只有一种形式。<br>过去分词和它的宾语或状语构成过去分词短语，在句中作定语、表语、宾补和状语，不能作主语和宾语。</p><p>怎么构成过去分词短语：</p><blockquote><p>过去分词短语必须由及物动词构成，必须含有被动意义。</p><ul><li>及物动词过去分词 + 状语（可以是时间、地点或方式状语）<ul><li>killed last night（昨晚被杀）</li><li>made in China（在中国被制造）</li></ul></li><li>双宾动词过去分词 + 宾语 + 状语（少数情况）<ul><li>given a book last night（昨晚被给一本书）</li></ul></li><li>特定的及物动词过去分词 + 名词作补语（少数情况）<ul><li>called Jack（被人叫做杰克）</li></ul></li></ul></blockquote><p>过去分词及短语作定语：</p><blockquote><ul><li>过去分词作前置定语<ul><li>相当于形容词的作用，不过意思还是动词的意思，表示已经完成或被动意义。</li><li>单独一个不及物动词过去分词只能表示完成意义，不能表示被动意义。</li></ul></li><li>过去分词短语作后置定语<ul><li>必须放在被修饰的名词后面作后置定语。</li><li>被修饰的名词和过去分词之间的动作含有被动的关系。</li><li>被修饰的名词一般需要加定冠词 the。</li></ul></li></ul></blockquote><p>过去分词及短语作表语：</p><blockquote><ul><li>只有单独一个过去分词才可以作表语，相当于一个形容词，主语一般是表示人的名词。</li><li>过去分词短语是不能作表语的，因为会变成被动语态。</li></ul></blockquote><p>过去分词及短语作宾补：</p><blockquote><ul><li>单独一个过去分词或过去分词短语只能在特定的动词后面作宾补。</li><li>宾语和宾补是被动的关系。</li></ul></blockquote><p>过去分词短语作状语：</p><blockquote><ul><li>修饰谓语，说明动作发生的背景或情况。</li><li>强调被动关系，多数情况放在句首，少数情况放在句尾或者中间。</li><li>将原因状语从句的连接词、主语和被动语态的助动词去掉，就得到了过去分词短语作原因状语。</li></ul></blockquote><h4 id="现在分词"><a href="#现在分词" class="headerlink" title="现在分词"></a>现在分词</h4><p>现在分词跟宾语或状语构成现在分词短语。<br>和动名词一样也是由“动词原形 + ing”构成，作非谓语时可以将现在分词当作动名词。</p><p>现在分词及短语作定语：</p><blockquote><ul><li>现在分词作前置定语：<ul><li>一个单独的现在分词作前置定语相当于一个形容词的作用。</li><li>其实可以将“现在分词 + 名词”看作一个复合名词。</li></ul></li><li>现在分词短语作后置定语：<ul><li>表示正在进行或当时正在进行的动作，多修饰表示人的名词。</li><li>表示经常性、习惯性的动作或现在的状态，可以修饰表示人以及其他的名词。</li></ul></li></ul></blockquote><p>现在分词及短语作表语：</p><blockquote><ul><li>现在分词作表语和过去分词作表语一样，都是相当于一个形容词。</li><li>现在分词作表语的时候多是表示主语的特征，且主语通常是没有生命的名词。</li><li>现在分词短语作表语就是动名词作表语。</li></ul></blockquote><p>现在分词及短语作宾补：</p><blockquote><ul><li>现在分词及短语表示正在发生或进行的动作，其含义相当于进行时态。</li></ul></blockquote><p>现在分词短语和不定式短语作宾补的区别：</p><blockquote><ul><li>不定式短语作宾补的情况比现在分词短语作宾补的情况多很多。<ul><li>能跟不定式短语作宾补的及物动词比能跟现在分词短语作宾补的及物动词多。</li></ul></li><li>现在分词短语作宾补特别强调正在进行的动作，不定式短语作宾补只强调一般的动作或状态。<ul><li>不定式短语可以用“to be + 表语”的格式作宾补，而现在分词短语不能用“being + 表语”的格式作宾补。</li></ul></li></ul></blockquote><p>现在分词短语作状语：</p><blockquote><ul><li>现在分词短语作状语表示主动意义，大部分情况放在开头然后加逗号。</li><li>跟过去分词短语作状语一样，现在分词短语作状语也相当于某个状语从句。</li></ul></blockquote><h2 id="冠词"><a href="#冠词" class="headerlink" title="冠词"></a>冠词</h2><p>冠词是用在名词前面的一种修饰词，可以用来表明所修饰的名词是特指还是泛指。<br>在特指名词前，须用定冠词，在非特指名词前，须用不定冠词。</p><h3 id="定冠词"><a href="#定冠词" class="headerlink" title="定冠词"></a>定冠词</h3><p>定冠词有 the(这，这些)，表示特指、整体。<br>可以修饰可数名词单数、复数和不可数名词。<br>凡是特指的名词，都需要加定冠词 the，不管是可数名词单数、复数还是不可数名词。<br>the 可以和指示代词 this&#x2F;these&#x2F;that&#x2F;those 替换。</p><h3 id="不定冠词"><a href="#不定冠词" class="headerlink" title="不定冠词"></a>不定冠词</h3><p>不定冠词有 a 和 an 都表示“一”的意思，表示泛指、个体。<br>a 和 an 只能跟可数名词单数，不能跟不可数名词，也不能跟可数名词复数。<br>a 用在以辅音开头的名词，an 用在以元音开头的名词。比如：</p><blockquote><ul><li>a book(一本书)、a useful tool(一个有用的工具)</li><li>an hour(一个小时)、an old man(一个老人)、an English book(一本英语书)</li></ul></blockquote><h2 id="副词"><a href="#副词" class="headerlink" title="副词"></a>副词</h2><p>副词是指在句子中表示行为或状态特征的词，<br>用以修饰动词、形容词、其他副词或全句，表示时间、地点、程度、方式等概念。<br>出现多个副词时，排列顺序为：方式副词 &gt; 地点副词 &gt; 时间副词</p><h3 id="时间副词"><a href="#时间副词" class="headerlink" title="时间副词"></a>时间副词</h3><p>表示某事何时发生。<br>主要作时间状语，大部分情况放在句尾。<br>作时间状语时要特别注意时态问题。</p><h3 id="地点副词"><a href="#地点副词" class="headerlink" title="地点副词"></a>地点副词</h3><p>表示地点与位置关系，用来说明动作是在什么地方发生的。<br>作地点状语的时候通常不受时态影响。</p><h3 id="方式副词"><a href="#方式副词" class="headerlink" title="方式副词"></a>方式副词</h3><p>用来表示我们如何做某事的。<br>只能作方式状语，并且只能修饰实义动词。<br>只能用在动作型的句子里。</p><h3 id="程度副词"><a href="#程度副词" class="headerlink" title="程度副词"></a>程度副词</h3><p>告诉我们某事发生的程度或者发生了多少。<br>主要修饰形容词和方式副词，放在被修饰的形容词和方式副词前面。<br>可以根据表达的需要在形容词或方式副词前加上程度副词。</p><h3 id="频度副词"><a href="#频度副词" class="headerlink" title="频度副词"></a>频度副词</h3><p>表示事情发生的频率。<br>也是作状语，但位置特殊，放在实义动词前，系动词、助动词、情态动词后面。</p><h2 id="介词"><a href="#介词" class="headerlink" title="介词"></a>介词</h2><p>表示名词、代词等与句中其它词的关系。<br>介词也叫前置词，是一种虚词，不能单独作句子成分。</p><p>分类：</p><blockquote><ul><li>简单介词<ul><li>由一个单词组成的介词。</li></ul></li><li>复合介词<ul><li>由两个单词组成的介词。</li></ul></li><li>分词介词<ul><li>由分词充当的介词。</li></ul></li><li>短语介词<ul><li>由几个单词构成的一个很长的介词，不管多么长都当成一个介词。</li></ul></li></ul></blockquote><h3 id="介词宾语"><a href="#介词宾语" class="headerlink" title="介词宾语"></a>介词宾语</h3><p>介词后面的词语叫介词宾语。</p><h3 id="介词短语"><a href="#介词短语" class="headerlink" title="介词短语"></a>介词短语</h3><p>介词短语 &#x3D; 介词 + 介词宾语</p><blockquote><ul><li>介词 + 名词<ul><li>in China（在中国）</li><li>under the table（在桌子下）</li></ul></li><li>介词 + 人称代词宾格<ul><li>beside me（在我旁边）</li><li>behind him（在他后面）</li></ul></li><li>介词 + 数词<ul><li>in 1998（在 1998 年）</li><li>at 6:30（在 6 点 30 分）</li></ul></li><li>介词 + 动名词<ul><li>before having dinner（吃饭前）</li><li>about learning English（关于学英语）</li></ul></li></ul></blockquote><p>作用：</p><blockquote><ul><li>作状语<ul><li>I work in China（我在中国工作）介词短语 in China 作地点状语。</li><li>I was fat in 2015（我在 2015 年很胖）介词短语 in 2015 作时间状语。</li><li>I tell stories in English（我用英语讲故事）介词短语 in English 作方式状语。</li></ul></li><li>作后置定语<ul><li>The book on the table is red（桌子上的书是红色的）介词短语 on the table 作后置定语。</li></ul></li><li>作表语<ul><li>She is under the tree（她在树下）介词短语 under the tree 作表语。</li></ul></li><li>作宾补<ul><li>I put the money in the drawer（我把钱放在抽屉里）介词短语 in the drawer 作宾补。</li></ul></li><li>作主补<ul><li>My coat was put on the bed by me（我的大衣被我放在床上）介词短语 on the bed 作主补。</li></ul></li></ul></blockquote><h2 id="数词"><a href="#数词" class="headerlink" title="数词"></a>数词</h2><blockquote><ul><li>基数词<ul><li>基本数字。比如：1~9</li></ul></li><li>序数词<ul><li>有顺序的。比如：第一、第二等</li></ul></li></ul></blockquote><h2 id="量词"><a href="#量词" class="headerlink" title="量词"></a>量词</h2><p>构成方式：</p><blockquote><ul><li>a&#x2F;an&#x2F;one + 可数名词单数 + of<ul><li>a cup of（一杯）、a bucket of（一桶）、a box of（一箱）。</li></ul></li><li>数词 + 可数名词复数 + of<ul><li>two bottles of（两瓶）、three tins of（三罐）、ten boxes of（十箱）。</li></ul></li></ul></blockquote><p>构成要求：</p><blockquote><ul><li>有内部空间<ul><li>bag（袋子）、basket（篮子）、truck（卡车）。</li></ul></li><li>容器<ul><li>cup（杯子）、glass（玻璃杯）、bottle（瓶子）。</li></ul></li><li>符合逻辑<ul><li>bar（条）、piece（块）、loaf（条）。</li></ul></li></ul></blockquote><p>使用规则：</p><blockquote><ul><li>修饰不可数名词<ul><li>a cup of coffee（一杯咖啡）。</li><li>two cups of milk（两杯牛奶）。</li></ul></li><li>修饰可数名词的复数<ul><li>a box of apples（一箱苹果）。</li><li>two boxes of books（两箱书）。</li></ul></li><li>不能修饰可数名词单数</li></ul></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;英语十大词性：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;中文名称&lt;/th&gt;
&lt;th&gt;英文名称&lt;/th&gt;
&lt;th&gt;简写&lt;/th&gt;
&lt;th&gt;例子&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;名词&lt;/td&gt;
&lt;td&gt;noun&lt;/td&gt;
&lt;td&gt;n.&lt;/td&gt;
&lt;td&gt;student（学生）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;代词&lt;/td&gt;
&lt;td&gt;pronoun&lt;/td&gt;
&lt;td&gt;pron.&lt;/td&gt;
&lt;td&gt;you（你）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;形容词&lt;/td&gt;
&lt;td&gt;adjective&lt;/td&gt;
&lt;td&gt;adj.&lt;/td&gt;
&lt;td&gt;happy（高兴）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;副词&lt;/td&gt;
&lt;td&gt;adverb&lt;/td&gt;
&lt;td&gt;adv.&lt;/td&gt;
&lt;td&gt;quickly（迅速地）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;动词&lt;/td&gt;
&lt;td&gt;verb&lt;/td&gt;
&lt;td&gt;v.&lt;/td&gt;
&lt;td&gt;cut（砍、割）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;及物动词&lt;/td&gt;
&lt;td&gt;transitive verb&lt;/td&gt;
&lt;td&gt;vt.&lt;/td&gt;
&lt;td&gt;buy（买）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;不及物动词&lt;/td&gt;
&lt;td&gt;intransitive verb&lt;/td&gt;
&lt;td&gt;vi.&lt;/td&gt;
&lt;td&gt;cry（哭）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;数词&lt;/td&gt;
&lt;td&gt;numeral&lt;/td&gt;
&lt;td&gt;num.&lt;/td&gt;
&lt;td&gt;three（三）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;冠词&lt;/td&gt;
&lt;td&gt;article&lt;/td&gt;
&lt;td&gt;art.&lt;/td&gt;
&lt;td&gt;a（一个）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;介词&lt;/td&gt;
&lt;td&gt;preposition&lt;/td&gt;
&lt;td&gt;prep.&lt;/td&gt;
&lt;td&gt;at（在……）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;连词&lt;/td&gt;
&lt;td&gt;conjunction&lt;/td&gt;
&lt;td&gt;conj.&lt;/td&gt;
&lt;td&gt;and（和）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;感叹词&lt;/td&gt;
&lt;td&gt;interjection&lt;/td&gt;
&lt;td&gt;interj.&lt;/td&gt;
&lt;td&gt;oh（哦）&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;</summary>
    
    
    
    <category term="学习笔记" scheme="https://lisir.me/hexo-theme-keep/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="英语语法" scheme="https://lisir.me/hexo-theme-keep/tags/%E8%8B%B1%E8%AF%AD%E8%AF%AD%E6%B3%95/"/>
    
    <category term="词性" scheme="https://lisir.me/hexo-theme-keep/tags/%E8%AF%8D%E6%80%A7/"/>
    
  </entry>
  
  <entry>
    <title>英语语法 | 语态</title>
    <link href="https://lisir.me/hexo-theme-keep/posts/9e47et28/"/>
    <id>https://lisir.me/hexo-theme-keep/posts/9e47et28/</id>
    <published>2023-12-24T11:57:46.000Z</published>
    <updated>2024-09-02T06:10:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>语态是动词的一种形式，用来表明主语与谓语动词之间的关系。</p><span id="more"></span><hr><h2 id="主动语态"><a href="#主动语态" class="headerlink" title="主动语态"></a>主动语态</h2><p>主动语态表示主语是动作的执行者。<br>谓语动词是主动语态的句子叫主动句。</p><p>举个例子：</p><blockquote><ul><li>I learn English every day.（我每天学英语）</li></ul><p>主语 I 是谓语动词 learn 的动作执行者，learn 的动作是由 I 做的。所以这句话是一个主动句。</p></blockquote><h2 id="被动语态"><a href="#被动语态" class="headerlink" title="被动语态"></a>被动语态</h2><p>被动语态表示主语是动作的承受者。<br>谓语动词是被动语态的句子叫被动句。<br>只有及物动词才有被动语态，不及物动词是没有的。<br>除了用双宾动词构成的被动句有宾语，其他被动句都没有宾语。</p><p>举个例子：</p><blockquote><ul><li>English is learned everywhere.（英语到处被学）</li></ul><p>主语 English 是复合谓语 is learned 的动作承受者。所以这句话是一个被动句。</p></blockquote><p>被动语态的构成：</p><blockquote><ul><li>主语（+ 情态动词）+ 助动词 be + 及物动词过去分词</li></ul><p>助动词 be 没有意思，有时态、人称和数的变化，其变化规律与系动词 be 完全一样。</p></blockquote><p>时态变化：</p><table><thead><tr><th>时态</th><th>结构</th></tr></thead><tbody><tr><td>一般现在时态</td><td>主语 + is&#x2F;are&#x2F;am + 及物动词过去分词</td></tr><tr><td>一般过去时态</td><td>主语 + was&#x2F;were + 及物动词过去分词</td></tr><tr><td>一般将来时态</td><td>1. 主语 + will + be + 及物动词过去分词 <br> 2. 主语 + be going to + be + 及物动词过去分词</td></tr><tr><td>现在进行时态</td><td>主语 + is&#x2F;are&#x2F;am + being + 及物动词过去分词</td></tr><tr><td>现在完成时态</td><td>主语 + has&#x2F;have + been + 及物动词过去分词</td></tr></tbody></table><p>什么时候使用被动语态：</p><blockquote><ul><li>在不知道动作执行者是谁的时候。</li><li>当动作的执行者是泛指或不言自明的时候。</li><li>虽然可以说出动作执行者，但动作的承受者才是谈话的中心或特别需要强调。</li><li>出于礼貌，委婉而避免提及自己或对方。</li><li>用在文章标题、广告、新闻等里面（常常省略 be）。</li><li>当动作的执行者不是人时。</li></ul></blockquote><p>双宾动词变成被动语态的情况：</p><blockquote><ul><li>间接宾语作主语 + 助动词 be + 双宾动词过去分词 + 直接宾语</li><li>直接宾语作主语 + 助动词 be + 双宾动词过去分词 + to + 间接宾语</li></ul></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;语态是动词的一种形式，用来表明主语与谓语动词之间的关系。&lt;/p&gt;</summary>
    
    
    
    <category term="学习笔记" scheme="https://lisir.me/hexo-theme-keep/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="英语语法" scheme="https://lisir.me/hexo-theme-keep/tags/%E8%8B%B1%E8%AF%AD%E8%AF%AD%E6%B3%95/"/>
    
    <category term="语态" scheme="https://lisir.me/hexo-theme-keep/tags/%E8%AF%AD%E6%80%81/"/>
    
  </entry>
  
  <entry>
    <title>软件设计师 | 算法（待更新）</title>
    <link href="https://lisir.me/hexo-theme-keep/posts/404c980a/"/>
    <id>https://lisir.me/hexo-theme-keep/posts/404c980a/</id>
    <published>2023-05-18T03:17:58.000Z</published>
    <updated>2024-09-02T06:10:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>待更新</p><span id="more"></span><hr><h2 id="回溯法"><a href="#回溯法" class="headerlink" title="回溯法"></a>回溯法</h2><h2 id="分治法"><a href="#分治法" class="headerlink" title="分治法"></a>分治法</h2><h2 id="贪心法"><a href="#贪心法" class="headerlink" title="贪心法"></a>贪心法</h2><h2 id="动态规划法"><a href="#动态规划法" class="headerlink" title="动态规划法"></a>动态规划法</h2>]]></content>
    
    
    <summary type="html">&lt;p&gt;待更新&lt;/p&gt;</summary>
    
    
    
    <category term="证书考试" scheme="https://lisir.me/hexo-theme-keep/categories/%E8%AF%81%E4%B9%A6%E8%80%83%E8%AF%95/"/>
    
    
    <category term="软考" scheme="https://lisir.me/hexo-theme-keep/tags/%E8%BD%AF%E8%80%83/"/>
    
    <category term="软件设计师" scheme="https://lisir.me/hexo-theme-keep/tags/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/"/>
    
    <category term="算法" scheme="https://lisir.me/hexo-theme-keep/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>软件设计师 | 数据结构（待更新）</title>
    <link href="https://lisir.me/hexo-theme-keep/posts/3ce0bce2/"/>
    <id>https://lisir.me/hexo-theme-keep/posts/3ce0bce2/</id>
    <published>2023-05-18T03:17:52.000Z</published>
    <updated>2024-09-02T06:10:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>待更新</p><span id="more"></span><hr><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><h3 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><h2 id="顺序存储"><a href="#顺序存储" class="headerlink" title="顺序存储"></a>顺序存储</h2><h2 id="链式存储"><a href="#链式存储" class="headerlink" title="链式存储"></a>链式存储</h2><h2 id="线性结构"><a href="#线性结构" class="headerlink" title="线性结构"></a>线性结构</h2><h2 id="树形结构"><a href="#树形结构" class="headerlink" title="树形结构"></a>树形结构</h2><h2 id="图形结构"><a href="#图形结构" class="headerlink" title="图形结构"></a>图形结构</h2><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><h3 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h3><h3 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h3><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><h3 id="顺序查找"><a href="#顺序查找" class="headerlink" title="顺序查找"></a>顺序查找</h3><h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3>]]></content>
    
    
    <summary type="html">&lt;p&gt;待更新&lt;/p&gt;</summary>
    
    
    
    <category term="证书考试" scheme="https://lisir.me/hexo-theme-keep/categories/%E8%AF%81%E4%B9%A6%E8%80%83%E8%AF%95/"/>
    
    
    <category term="软考" scheme="https://lisir.me/hexo-theme-keep/tags/%E8%BD%AF%E8%80%83/"/>
    
    <category term="软件设计师" scheme="https://lisir.me/hexo-theme-keep/tags/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/"/>
    
    <category term="数据结构" scheme="https://lisir.me/hexo-theme-keep/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>软件设计师 | 计算机网络</title>
    <link href="https://lisir.me/hexo-theme-keep/posts/6f70781c/"/>
    <id>https://lisir.me/hexo-theme-keep/posts/6f70781c/</id>
    <published>2023-05-16T07:27:20.000Z</published>
    <updated>2024-09-02T06:10:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>计算机网络是计算机技术与通信技术相结合的产物，它实现了远程通信、远程信息处理和资源共享。</p><span id="more"></span><hr><h2 id="网络设备"><a href="#网络设备" class="headerlink" title="网络设备"></a>网络设备</h2><ul><li><p>物理层的互连设备有中继器和集线器。集线器是一个多端口的中继器。</p></li><li><p>数据链路层的互连设备有网桥和交换机。交换机是一个多端口的网桥。</p></li><li><p>网络层的互联设备有路由器。</p></li><li><p>应用层的互联设备有网关。</p></li></ul><h2 id="协议簇"><a href="#协议簇" class="headerlink" title="协议簇"></a>协议簇</h2><p><img                         lazyload                       alt="image"                       data-src="https://img.lisir.me/image/posts/6f70781c/20230516162051.png"                        alt="20230516162051"                 ></p><p><img                         lazyload                       alt="image"                       data-src="https://img.lisir.me/image/posts/6f70781c/20230516162809.png"                        alt="20230516162809"                 ></p><h3 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h3><p>TCP 的全称是传输控制协议是一种面向连接的、可靠的、基于字节流的传输层通信协议。TCP 是面向连接的、可靠的流协议（流就是指不间断的数据结构）。</p><ul><li>是一个可靠的、面向连接的全双工的数据传输协议。</li><li>TCP 是面向连接（虚连接）的传输层协议。</li><li>TCP 的流量控制采用了可变大小的滑动窗口协议。</li><li>TCP 提供可靠交付的服务，无差错、不丢失、不重复、按序到达。</li><li>每一条 TCP 连接只能有两个端点，每一条 TCP 连接只能是点对点的。</li><li>主机之间建立和关闭连接操作时，均需要通过三次握手来确认建立和关闭是否成功。</li></ul><h3 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h3><p>UDP 的全称是用户数据报协议，在网络中它与 TCP 协议一样用于处理数据包，是一种无连接的协议。在 OSI 模型中，在传输层，处于 IP 协议的上一层。UDP 有不提供数据包分组、组装和不能对数据包进行排序的缺点，也就是说，当报文发送之后，是无法得知其是否安全完整到达的。</p><ul><li>是一个不可靠的、无连接的协议。</li><li>UDP 有助于提高传输的高速率性。</li><li>UDP 是无连接的，减少开销和发送数据之前的时延。</li><li>UDP 使用最大努力交付，即不保证可靠交付。</li><li>UDP 是面向报文的，适合一次性传输少量数据的网络应用。</li><li>UDP 无拥塞控制，适合很多实时应用。</li><li>UDP 首部开销小。</li></ul><h2 id="ipconfig-工具"><a href="#ipconfig-工具" class="headerlink" title="ipconfig 工具"></a>ipconfig 工具</h2><ul><li>ipconfig：显示所有网络适配器的 IP 地址、子网拖码和缺省网关值。</li><li>ipconfig&#x2F;all：显示所有网络适配器的完整 TCP&#x2F;IP 配置信息，包括 DHCP 服务是否已启动。</li><li>ipconfig&#x2F;renew：DHCP 客户端手工向服务器刷新请求（重新申请 IP 地址）。</li><li>ipconfig&#x2F;release：DHCP 客户端手工释放 IP 地址。</li><li>ipconfig&#x2F;flushdns：清除本地 DNS 缓存内容。</li><li>ipconfig&#x2F;displaydns：显示本地 DNS 内容。</li><li>ipconfig&#x2F;registerdns：DNS 客户端手工向服务器进行注册。</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;计算机网络是计算机技术与通信技术相结合的产物，它实现了远程通信、远程信息处理和资源共享。&lt;/p&gt;</summary>
    
    
    
    <category term="证书考试" scheme="https://lisir.me/hexo-theme-keep/categories/%E8%AF%81%E4%B9%A6%E8%80%83%E8%AF%95/"/>
    
    
    <category term="软考" scheme="https://lisir.me/hexo-theme-keep/tags/%E8%BD%AF%E8%80%83/"/>
    
    <category term="软件设计师" scheme="https://lisir.me/hexo-theme-keep/tags/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/"/>
    
    <category term="计算机网络" scheme="https://lisir.me/hexo-theme-keep/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>软件设计师 | 软件工程</title>
    <link href="https://lisir.me/hexo-theme-keep/posts/4357767a/"/>
    <id>https://lisir.me/hexo-theme-keep/posts/4357767a/</id>
    <published>2023-05-14T02:57:13.000Z</published>
    <updated>2024-09-02T06:10:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>软件工程是指应用计算机科学、数学及管理科学等原理，以工程化的原则和方法来解决软件问题的工程，其目的是提高软件生产率、提高软件质量、降低软件成本。</p><span id="more"></span><hr><h2 id="软件过程"><a href="#软件过程" class="headerlink" title="软件过程"></a>软件过程</h2><h3 id="能力成熟度模型"><a href="#能力成熟度模型" class="headerlink" title="能力成熟度模型"></a>能力成熟度模型</h3><p>能力成熟度模型（CMM）将软件过程改进分为以下 5 个成熟度级别。</p><ol><li><p>初始级。软件过程的特点是杂乱无章，有时甚至很混乱，几乎没有明确定义的步骤，项目的成功完全依赖个人的努力和英雄式核心人物的作用。</p></li><li><p>可重复级。建立了基本的项目管理过程和实践来跟踪项目费用、进度和功能特性，有必要的过程准则来重复以前在同类项目中的成功。</p></li><li><p>已定义级。管理和工程两方面的软件过程已经文档化、标准化，并综合成整个软件开发组织的标准软件过程。所有项目都采用根据实际情况修改后得到的标准软件过程来开发和维护软件。</p></li><li><p>已管理级。制定了软件过程和产品质量的详细度量标准。软件过程的产品质量都被开发组织的成员所理解和控制。</p></li><li><p>优化级。加强了定量分析，通过来自过程质量反馈和来自新观念、新技术的反馈使过程能不断持续地改进。</p></li></ol><h3 id="能力成熟度模型集成"><a href="#能力成熟度模型集成" class="headerlink" title="能力成熟度模型集成"></a>能力成熟度模型集成</h3><p>能力成熟度模型集成（CMMI）提供了两种表示方法：阶段式模型和连续式模型。</p><h4 id="阶段式模型"><a href="#阶段式模型" class="headerlink" title="阶段式模型"></a>阶段式模型</h4><p>阶段式模型的结构类似于 CMM，它关注组织的成熟度。</p><ul><li><p>初始的：过程不可预测且缺乏控制。</p></li><li><p>已管理的：过程为项目服务。</p></li><li><p>已定义的：过程为组织服务。</p></li><li><p>定量管理的：过程已度量和控制。</p></li><li><p>优化的：集中于过程改进。</p></li></ul><h4 id="连续式模型"><a href="#连续式模型" class="headerlink" title="连续式模型"></a>连续式模型</h4><p>连续式模型关注每个过程域的能力，一个组织对不同的过程域可以达到不同的过程域能力等级。CMMI 中包括 6 个过程域能力等级，等级号为 0~5。</p><p>能力等级可以独立地应用于任何单独的过程域，任何一个能力等级都必须满足比它等级低的能力等级的所有准则。对各能力等级的含义简述如下。</p><ul><li><p>未完成的：过程域未执行或未得到“已执行的”中定义的所有目标。</p></li><li><p>已执行的：其共性目标是过程将可标识的输入工作产品转换成可标识的输出工作产品，以实现支持过程域的特定目标。</p></li><li><p>已管理的：其共性目标集中于已管理的过程的制度化。根据组织级政策规定过程的运作将使用哪个过程，项目遵循已文档化的计划和过程描述，所有正在工作的人都有权使用足够的资源，所有工作任务和工作产品都被监控、控制和评审。</p></li><li><p>已定义级的：其共性目标集中于已定义的过程的制度化。过程是按照组织的剪裁指南从组织的标准过程集中剪裁得到的，还必须收集过程资产和过程的度量，并用于将来对过程的改进。</p></li><li><p>定量管理的：其共性目标集中于可定量管理的过程的制度化。使用测量和质量保证来控制和改进过程域，建立和使用关于质量和过程执行的定量目标作为管理准则。</p></li><li><p>优化的：使用量化（统计学）手段改变和优化过程域，以满足客户要求的改变和持续改进计划中的过程域的功效。</p></li></ul><h2 id="软件过程模型"><a href="#软件过程模型" class="headerlink" title="软件过程模型"></a>软件过程模型</h2><p>软件过程模型习惯上也称为软件开发模型，它是软件开发全部过程、活动和任务的结构框架。典型的软件过程模型有瀑布模型、增量模型、演化模型（原型模型、螺旋模型）、喷泉模型、基于构件的开发模型和形式化方法模型等。</p><h3 id="瀑布模型"><a href="#瀑布模型" class="headerlink" title="瀑布模型"></a>瀑布模型</h3><p>瀑布模型是将软件生存周期中的各个活动规定为依线性顺序连接的若干阶段的模型，包括需求分析、设计、编码、测试、运行与维护。它规定了由前至后、相互衔接的固定次序，如同瀑布流水逐级下落，如下图所示。</p><p><img lazyload="" alt="20230514141005" data-src="https://img.lisir.me/image/posts/4357767a/20230514141005.png"></p><p><strong>优点：</strong></p><ul><li>容易理解和管理，且管理成本低。</li><li>过程可见，项目经理能够根据项目计划监控项目过程。</li></ul><p><strong>缺点：</strong></p><ul><li>客户必须能够完整、正确和清晰地表达他们的需要。</li><li>在开始的两个或三个阶段中，很难评估真正的进度状态。</li><li>当接近项目结束时，出现了大量的集成和测试工作。</li><li>直到项目结束之前，都不能演示系统的能力。</li><li>需求或设计中的错误往往只有到了项目后期才能够被发现。</li><li>对于项目风险的控制能力较弱，从而导致项目常常延期完成，开发费用超出预算。</li></ul><p><strong>适用范围：</strong></p><ul><li>瀑布模型是以文档作为驱动，适合于软件需求很明确的软件项目的模型。</li><li>系统开发过程中不太可能发生重大改变。</li></ul><h3 id="V-模型"><a href="#V-模型" class="headerlink" title="V 模型"></a>V 模型</h3><p>V 模型是瀑布模型的一个变体，强调在各个阶段进行测试和验证，以提升软件质量。</p><p><img lazyload="" alt="20230514144048" data-src="https://img.lisir.me/image/posts/4357767a/20230514144048.png"></p><p>左侧大体遵照瀑布模型，在编码完成后反弹，逐阶段测试。</p><p>优缺点：</p><ul><li>V 模型是瀑布模型的一种加强，可以提升软件质量，但也更消耗人力和时间。</li></ul><h3 id="增量模型"><a href="#增量模型" class="headerlink" title="增量模型"></a>增量模型</h3><p>增量模型，先开发出一个初始的实现，给用户使用并听取用户的使用意见，通过不断修改直到产生一个充分的版本。各活动不是分离而是交织在一起的。反应了我们解决问题的方法，我们很少能提前制定出完整的问题解决方案，而是摸着石头过河，逐步逼近结果。</p><p>增量模型融合了瀑布模型的基本成分和原型实现的送代特征，它假设可以将需求分段为一系列增量产品，每一增量可以分别开发。</p><p>当使用增量模型时，第一个增量往往是核心的产品。客户对每个增量的使用和评估都作为下一个增量发布的新特征和功能，这个过程在每一个增量发布后不断重复，直到产生了最终的完善产品。增量模型强调每个增量均发布一个可操作的产品。</p><p><img lazyload="" alt="20230514145606" data-src="https://img.lisir.me/image/posts/4357767a/20230514145606.png"></p><p><strong>优点：</strong></p><ul><li>增量模型作为瀑布模型的一个变体，具有瀑布模型的所有优点。</li><li>第一个可交付版本所需要的成本和时间很少。</li><li>开发由增量表示的小系统所承担的风险不大。</li><li>由于很快发布了第一个版本，因此可以减少用户需求的变更。</li><li>运行增量投资，即在项目开始时，可以仅对一个或两个增量投资。</li><li>用户可以更早的使用软件并创造价值。</li></ul><p><strong>缺点：</strong></p><ul><li>过程不可见，不方便管理。</li><li>缺乏整体规划，导致功能堆砌。</li><li>越往后变更越困难，成本逐渐上升。</li><li>如果没有对用户的变更要求进行规划，那么产生的初始增量可能会造成后来增量的不稳定。</li><li>如果需求不像早期思考的那样稳定和完整，那么一些增量就可能需要重新开发，重新发布。</li><li>管理发生的成本、进度和配置的复杂性可能会超出组织的能力。</li></ul><p><strong>适用范围：</strong></p><ul><li>软件产品可以分批次地进行交付。</li><li>待开发的软件系统能够被模块化。</li><li>软件开发人员对应用领域不熟悉，难以一次性地进行系统开发。</li><li>项目管理人员把握全局的水平较高。</li><li>需要快速构造可运行的产品。</li><li>开发团队人力资源、时间不充足的情况。</li></ul><h3 id="演化模型"><a href="#演化模型" class="headerlink" title="演化模型"></a>演化模型</h3><p>软件类似于其他复杂的系统，会随着时间的推移而演化。演化模型主要针对事先不能完整定义需求的软件开发。</p><p>在开发过程中，常常会面临以下情形：</p><ul><li>商业和产品需求经常发生变化，直接导致最终产品难以实现。</li><li>严格的交付时间使得开发团队不可能圆满地完成软件产品，但是必须交付功能有限的版本以应对竞争或商业压力。</li><li>很好地理解了核心产品和系统需求，但是产品或系统扩展的细节问题却没有定义。</li></ul><p>在上述情况和类似情况下，软件开发人员需要一种专门应对不断演变的软件产品的过程模型。</p><p>演化模型是送代的过程模型，使得软件开发人员能够逐步开发出更完整的软件版本。演化模型特别适用于对软件需求缺乏准确认识的情况。典型的演化模型有原型模型和螺旋模型等。</p><h3 id="原型模型"><a href="#原型模型" class="headerlink" title="原型模型"></a>原型模型</h3><p>并非所有的需求都能够预先定义，大量的实践表明，在开发初期很难得到一个完整的、准确的需求规格说明。这主要是由于客户往往不能准确地表达对未来系统的全面要求，开发者对要解决的应用问题模糊不清，以至于形成的需求规格说明常常是不完整的、不准确的，有时甚全是有歧异的。</p><p>在整个开发过程中，用户可能会产生新的要求，导致需求的变更。而瀑布模型难以适应这种需求的不确定性和变化，于是出现了快速原型这种新的开发方法。</p><p><img lazyload="" alt="20230514145700" data-src="https://img.lisir.me/image/posts/4357767a/20230514145700.png"></p><p>原型开发模型开始于沟通，开发人员和用户沟通，了解软件整体目标，明确已知需求，大致勾画出以后进一步定义的东西，然后迅速策划一个原型，进行建模，快速开发一个原型，对原型进行部署，由相关人员进行评价，根据评价进一步细化软件的需求，不断调整已满足需求。</p><p><strong>优点：</strong></p><ul><li>有助于启发和验证系统需求。</li><li>可以有效地捕获系统的需求。</li></ul><p><strong>缺点：</strong></p><ul><li>原型开发会忽略掉非功能性要求 ，如性能、安全性、可靠性等。</li><li>开发过程的快速更改意味着没有文档，唯一的设计描述是原型的代码，这不利于长期的维护。</li></ul><p><strong>适用范围：</strong></p><ul><li>用户需求模糊、需求经常变化。</li><li>系统规模不是很大也不太复杂时，采用该方法比较好。</li><li>开发人员对算法效率、操作系统的兼容性，人机交互形式等情况不明确。</li></ul><p>根据使用原型的目的不同，原型可以分为探索型原型、实验型原型和演化型原型 3 种。</p><ul><li>探索型原型的目的是要弄清目标的要求，确定所希望的特性，并探讨多种方案的可行性。</li><li>实验型原型的目的是验证方案或算法的合理性，是在大规模开发和实现前，用于考查方案是否合适、规格说明是否可靠等。</li><li>演化型原型的目的是将原型作为目标系统的一部分，通过对原型的多次改进，逐步将原型演化成最终的目标系统。</li></ul><h3 id="螺旋模型"><a href="#螺旋模型" class="headerlink" title="螺旋模型"></a>螺旋模型</h3><p>对于复杂的大型软件，开发一个原型往往达不到要求。螺旋模型将瀑布模型和演化模型结合起来，加入了两种模型均忽略的风险分析，弥补了这两种模型的不足。</p><p><img lazyload="" alt="20230514145726" data-src="https://img.lisir.me/image/posts/4357767a/20230514145726.png"></p><p>螺旋模型将开发过程分为几个螺旋周期，每个螺旋周期大致和瀑布模型相符合。每个螺旋周期分为如下 4 个工作步骤。</p><ul><li>制订计划：确定软件的目标，选定实施方案，明确项目开发的限制条件。</li><li>风险分析：分析所选的方案，识别风险，消除风险。</li><li>实施工程：实施软件开发，验证阶段性产品。</li><li>用户评估：评价开发工作，提出修正建议，建立下一个周期的开发计划。</li></ul><p>螺旋模型强调风险分析，使得开发人员和用户对每个演化层出现的风险有所了解，从而做出应有的反应。</p><p><strong>优点：</strong></p><ul><li>实现风险管理，降低变更风险。</li><li>确定一系列里程碑，确保利益相关者都能支持。</li><li>与瀑布模型相比，螺旋模型支持用户需求的动态变化。</li><li>为用户参与软件开发的所有关键决策提供了方便，有助于提高软件的适应能力。</li><li>为项目管理人员及时调整管理决策提供了便利，从而降低了软件开发的风险。</li></ul><p><strong>缺点：</strong></p><ul><li>很难说服客户以合同形式合作。</li><li>依赖大量风险评估专家及风险评估工作。</li><li>过多的迭代次数会增加开发成本，延迟提交时间。</li><li>需要开发人员具有相当丰富的风险评估经验和专门知识。</li></ul><p><strong>适用范围：</strong></p><ul><li>开发大型系统和软件。</li><li>预期存在较大风险的项目。</li><li>适用于庞大、复杂并且具有高风险的系统。</li></ul><h3 id="喷泉模型"><a href="#喷泉模型" class="headerlink" title="喷泉模型"></a>喷泉模型</h3><p>喷泉模型是一种以用户需求为动力，以对象作为驱动的模型，适合于面向对象的开发方法。该模型认为软件开发过程自下而上周期的各阶段是相互迭代和无间隙的。</p><p>软件的某个部分常常被重复工作多次，相关对象在每次迭代中随之加入渐进的软件成分。由于对象概念的引入，表达分析、设计、实现等活动只用对象类和关系，从而可以较为容易地实现活动的迭代和无间隙（无间隙指在各项活动之间无明显边界，如分析和设计活动之间没有明显的界限）。</p><p><img lazyload="" alt="20230514145743" data-src="https://img.lisir.me/image/posts/4357767a/20230514145743.png"></p><p><strong>优点：</strong></p><ul><li>可以提高软件项目的开发效率，节省开发时间。</li><li>喷泉模型的各个阶段没有明显的界线，开发人员可以同步进行。</li><li>克服了瀑布模型不支持软件重用和多项开发活动集成的局限性。</li><li>将功能需求、功能模块间的关系、数据流等描述清楚，提升需求、设计准确性，最终提升软件质量。</li></ul><p><strong>缺点：</strong></p><ul><li>各个阶段有重叠，在开发过程中需要大量的开发人员，不利于项目的管理。</li><li>这种模型要求严格管理文档，使得审核的难度加大。</li></ul><h3 id="统一过程模型"><a href="#统一过程模型" class="headerlink" title="统一过程模型"></a>统一过程模型</h3><p>统一过程模型是一种“用例驱动，以体系结构为核心，迭代及增量”的软件过程框架，由 UML 方法和工具支持。</p><p>统一过程定义了 4 个技术阶段及其制品。</p><ol><li><p>起始阶段。起始阶段专注于项目的初创活动，产生的主要工作产品有构想文档、初始用例模型、初始项目术语表、初始业务用例、初始风险评估、项目计划（阶段及送代）、业务模型以及一个或多个原型（需要时）。</p></li><li><p>精化阶段。精化阶段在理解了最初的领域范围之后进行需求分析和架构演进，产生的主要工作产品有用例模型、补充需求（包括非功能需求）、分析模型、软件体系结构描述、可执行的软件体系结构原型、初步的设计模型、修订的风险列表、项目计划（包括送代计划、调整的工作流、里程碑和技术工作产品）以及初始用户手册。</p></li><li><p>构建阶段。构建阶段关注系统的构建，产生实现模型，产生的主要工作产品有设计模型、软件构件、集成的软件增量、测试计划及步骤、测试用例以及支持文档（用户手册、安装手册和对于并发增量的描述）。</p></li><li><p>移交阶段。移交阶段关注于软件提交方面的工作，产生软件增量，产生的主要工作产品有提交的软件增量、测试报告和综合用户反馈。</p></li></ol><p>在每个送代中有 5 个核心工作流。</p><ul><li>捕获系统应该做什么的需求工作流。</li><li>精化和结构化需求的分析工作流。</li><li>在系统构架内实现需求的设计工作流</li><li>构造软件的实现工作流。</li><li>验证实现是否如期望那样工作的测试工作流。</li></ul><p>随着统一过程模型的阶段进展，每个核心工作流的工作量发生了变化。4 个技术阶段由主要里程硬所终止。</p><ul><li>初始阶段：生命周期目标。</li><li>精化阶段：生命周期架构。</li><li>构建阶段：初始运作功能。</li><li>移交阶段：产品发布。</li></ul><h3 id="敏捷方法"><a href="#敏捷方法" class="headerlink" title="敏捷方法"></a>敏捷方法</h3><p>敏捷开发的总体目标是通过“尽可能早地、持续地对有价值的软件的交付”使客户满意。</p><h4 id="极限编程"><a href="#极限编程" class="headerlink" title="极限编程"></a>极限编程</h4><p>极限编程（XP）是一种轻量级（敏捷）、高效、低风险、柔性、可预测的、科学的软件开发方式。它由价值观、原则、实践和行为 4 个部分组成，彼此相互依赖、关联，并通过行为贯穿于整个生存周期。</p><ul><li>4 大价值观<ul><li>沟通、简单性、反馈和勇气。</li></ul></li><li>5 个原则<ul><li>快速反馈、简单性假设、逐步修改、提倡更改和优质工作。</li></ul></li><li>12 个最佳实践<ul><li>计划游戏：快速制定计划、随着细节的不断变化而完善。</li><li>小型发布：系统的设计要能够尽可能早地交付。</li><li>简单设计：只处理当前的需求，使设计保持简单。</li><li>测试先行：先写测试代码，然后再编写程序。</li><li>持续集成：可以按日甚至按小时为客户提供可运行的版本。</li><li>隐喻：找到合适的比喻传达信息。</li><li>重构：重新审视需求和设计，重新明确地描述它们以符合新的和现有的需求。</li><li>结队编程。</li><li>集体代码所有制。</li><li>每周工作 40 个小时。</li><li>现场客户和编码标准。</li></ul></li></ul><h4 id="水晶法"><a href="#水晶法" class="headerlink" title="水晶法"></a>水晶法</h4><p>水晶法认为每一个不同的项目都需要一套不同的策略、约定和方法论，认为人对软件质量有重要的影响，因此随着项目质量和开发人员素质的提高，项目和过程的质量也随之提高。通过更好地交流和经常性的交付，软件生产力得到提高。</p><h4 id="并列争求法"><a href="#并列争求法" class="headerlink" title="并列争求法"></a>并列争求法</h4><p>并列争求法使用迭代的方法，其中，把每 30 天一次的送代称为一个“冲刺”，并按需求的优先级别来实现产品。多个自组织和自治的小组并行地递增实现产品。协调是通过简短的日常情况会议来进行，就像橄榄球中的“并列争球”。</p><h4 id="自适应软件开发"><a href="#自适应软件开发" class="headerlink" title="自适应软件开发"></a>自适应软件开发</h4><p>ASD 有 6 个基本的原则：</p><ul><li>有一个使命作为指导。</li><li>特征被视为客户价值的关键点。</li><li>过程中的等待是很重要的，因此“重做”与“做”同样关键。</li><li>变化不被视为改正，而是被视为对软件开发实际情况的调整。</li><li>确定的交付时间迫使开发人员认真考虑每一个生产的版本的关键需求。</li><li>风险也包含其中。</li></ul><h4 id="敏捷统一过程"><a href="#敏捷统一过程" class="headerlink" title="敏捷统一过程"></a>敏捷统一过程</h4><p>敏捷统一过程采用“在大型上连续”以及在“在小型上送代”的原理来构建软件系统。采用经典的统一过程模型（UP）阶段性活动（初始、精化、构建和转换），提供了一系列活动，能够使团队为软件项目构想出一个全面的过程流。在每个活动里，一个团队迭代使用敏捷，并将有意义的软件增量尽可能快地交付给最终用户。</p><p>每个敏捷统一过程（AUP）迭代执行以下活动：</p><ul><li>建模：建立对商业和问题域的模型表述，这些模型“足够好”即可，以便团队继续前进。</li><li>实现：将模型翻译成源代码。</li><li>测试：像极限编程一样，团队设计和执行一系列的测试来发现错误以保证源代码满足需求。</li><li>部署：对软件增量的交付以及获取最终用户的反馈。</li><li>配置及项目管理：着眼于变更管理、风险管理以及对团队的任一制品的控制。项目管理追踪和控制开发团队的工作进展并协调团队活动。</li><li>环境管理：协调标准、工具以及适用于开发团队的支持技术等过程基础设施。</li></ul><h2 id="软件需求"><a href="#软件需求" class="headerlink" title="软件需求"></a>软件需求</h2><ul><li><p>功能需求：考虑系统要做什么，在何时做，在何时以及如何修改或升级。</p></li><li><p>性能需求：考虑软件开发的技术性指标。例如，存储容量限制、执行速度、响应时间及吞吐量。</p></li><li><p>用户或人的因素：考虑用户的类型。例如，各种用户对使用计算机的熟练程度，需要接受的训练，用户理解、使用系统的难度，用户错误操作系统的可能性等。</p></li><li><p>环境需求：考虑未来软件应用的环境，包括硬件和软件。对硬件设备的需求包括机型、外设、接口、地点、分布、湿度、磁场干扰等；对软件的需求包括操作系统、网络、数据库等。</p></li><li><p>界面需求：考虑来自其他系统的输入，到其他系统的输出，对数据格式的特殊规定，对数据存储介质的规定。</p></li><li><p>文档需求：考虑需要哪些文档，文档针对哪些读者。</p></li><li><p>数据需求：考虑输入、输出数据的格式，接收、发送数据的频率，数据的准确性和精度，数据流量，数据需保持的时间。</p></li><li><p>资源使用需求：考虑软件运行时所需要的数据、其他软件、内存空间等资源；软件开发、维护所需的人力、支撑软件、开发设备等。</p></li><li><p>安全保密要求：考虑是否需要对访问系统或系统信息加以控制，隔离用户数据的方法，用户程序如何与其他程序和操作系统隔离以及系统备份要求等。</p></li><li><p>可靠性要求：考虑系统的可靠性要求，系统是否必须检测和隔离错误；出错后，重启系统允许的时间等。</p></li><li><p>软件成本消耗与开发进度需求：考虑开发是否有规定的时间表，软/硬件投资有无限制等。</p></li><li><p>其他非功能性要求：如采用某种开发模式，确定质量控制标准、里程碑和评审、验收标准、各种质量要求的优先级等，以及可维护性方面的要求。</p></li></ul><h2 id="软件设计"><a href="#软件设计" class="headerlink" title="软件设计"></a>软件设计</h2><h3 id="概要设计"><a href="#概要设计" class="headerlink" title="概要设计"></a>概要设计</h3><ul><li>设计软件系统总体结构<ul><li>其基本任务是采用某种设计方法，将一个复杂的系统按功能划分成模块。</li><li>确定每个模块的功能。</li><li>确定模块之间的调用关系。</li><li>确定模块之间的接口，即模块之间传递的信息。</li><li>评价模块结构的质量。</li></ul></li><li>数据结构及数据库设计</li><li>编写概要设计文档。文档主要有概要设计说明书、数据库设计说明书、用户手册以及修订测试计划。</li><li>评审。对设计部分是否完整地实现了需求中规定的功能、性能等要求，设计方法的可行性，关键的处理及内外部接口定义的正确性、有效性、各部分之间的一致性等都一一进行评审。</li></ul><h3 id="详细设计"><a href="#详细设计" class="headerlink" title="详细设计"></a>详细设计</h3><ul><li>对每个模块进行详细的算法设计，用某种图形、表格和语言等工具将每个模块处理过程的详细算法描述出来。</li><li>对模块内的数据结构进行设计。</li><li>对数据库进行物理设计，即确定数据库的物理结构。</li><li>其他设计。根据软件系统的类型，还可能要进行以下设计。<ul><li>代码设计。</li><li>输入/输出格式设计。</li><li>用户界面设计。</li></ul></li><li>编写详细设计说明书。</li><li>评审。对处理过程的算法和数据库的物理结构都要评审。</li></ul><h2 id="软件测试"><a href="#软件测试" class="headerlink" title="软件测试"></a>软件测试</h2><p>软件测试是为了发现错误而执行程序的过程，成功的测试是发现了全今尚未发现的错误的测试。</p><p>测试的目的就是希望能以最少的人力和时间发现潜在的各种错误和缺陷。用户应根据开发各阶段的需求、设计等文档或程序的内部结构精心设计测试实例，并利用这些实例来运行程序，以便发现错误的过程。</p><p>根据测试的概念和目的，在进行信息软件测试时应遵循以下基本原则。</p><ol><li><p>应尽早并不断地进行测试。测试不是在应用系统开发完之后才进行的。由于原始问题的复杂性、开发各阶段的多样性以及参加人员之间的协调等因素，使得在开发的各个阶段都有可能出现错误。因此，测试应贯穿在开发的各个阶段，应尽早纠正错误，消除隐患。</p></li><li><p>测试工作应该避免由原开发软件的人或小组承担，一方面，开发人员往往不愿否认自已的工作，总认为自己开发的软件没有错误；另一方面，开发人员的错误很难由本人测试出来，很容易根据自己编程的思路来制定测试思路，具有局限性。测试工作应由专门人员来进行，这样会更客观、更有效。</p></li><li><p>在设计测试方案时，不仅要确定输入数据，而且要根据系统功能确定预期输出结果。将实际输出结果与预期结果相比较就能发现测试对象是否正确。</p></li><li><p>在设计测试用例时，不仅要设计有效、合理的输入条件，也要包含不合理、失效的输入条件。在测试的时候，人们往往习惯按照合理的、正常的情况进行测试，而忽略了对异常、不合理、意想不到的情况进行测试，而这可能就是隐患。</p></li><li><p>在测试程序时，不仅要检验程序是否做了该做的事，还要检验程序是否做了不该做的事。多余的工作会带来副作用，影响程序的效率，有时会带来潜在的危害或错误。</p></li><li><p>严格按照测试计划来进行，避免测试的随意性。测试计划应包括测试内容、进度安排、人员安排、测试环境、测试工具和测试资料等。严格地按照测试计划可以保证进度，使各方面都得以协调进行。</p></li><li><p>妥善保存测试计划、测试用例，作为软件文档的组成部分，为维护提供方便。</p></li><li><p>测试用例都是精心设计出来的，可以为重新测试或追加测试提供方便。当纠正错误、系统功能扩充后，都需要重新开始测试，而这些工作的重复性很高，可以利用以前的测试用例或在其基础上修改，然后进行测试。</p></li></ol><h3 id="测试方法"><a href="#测试方法" class="headerlink" title="测试方法"></a>测试方法</h3><p>在软件测试过程中，应该为定义软件测试模板，即将特定的测试方法和测试用例设计放在一系列的测试步骤中。</p><p>软件测试方法分为静态测试和动态测试。</p><ol><li><p>静态测试。静态测试是指被测试程序不在机器上运行，而是采用人工检测和计算机辅助静态分析的手段对程序进行检测。</p></li><li><p>动态测试。动态测试是指通过运行程序发现错误。在对软件产品进行动态测试时可以采用黑盒测试法和白盒测试法。</p></li></ol><h3 id="黑盒测试"><a href="#黑盒测试" class="headerlink" title="黑盒测试"></a>黑盒测试</h3><p>黑盒测试也称为功能测试，在完全不考虑软件的内部结构和特性的情况下，测试软件的外部特性。</p><p>常用的黑盒测试技术有等价类划分、边界值分析、错误推测和因果图等。</p><ol><li><p>等价类划分。等价类划分法将程序的输入域划分为若干等价类，然后从每个等价类中选取一个代表性数据作为测试用例。每一类的代表性数据在测试中的作用等价于这一类中的其他值，这样就可以用少量代表性的测试用例取得较好的测试效果。等价类划分有两种不同的情况：有效等价类和无效等价类。在设计测试用例时，要同时考虑这两种等价类。</p></li><li><p>边界值分析。输入的边界比中间更加容易发生错误，因此用边界值分析来补充等价类划分的测试用例设计技术。边界值划分选择等价类边界的测试用例，既注重于输入条件边界，又适用于输出域测试用例。</p></li></ol><h3 id="白盒测试"><a href="#白盒测试" class="headerlink" title="白盒测试"></a>白盒测试</h3><p>白盒测试也称为结构测试，根据程序的内部结构和逻辑来设计测试用例，对程序的路径和过程进行测试，检查是否满足设计的需要。</p><p>白盒测试常用的技术是逻辑覆盖、循环覆盖和基本路径测试。</p><h4 id="逻辑覆盖"><a href="#逻辑覆盖" class="headerlink" title="逻辑覆盖"></a>逻辑覆盖</h4><p>逻辑覆盖考察用测试数据运行被测程序时对程序逻辑的覆盖程度，主要的逻辑覆盖标准有语句覆盖、判定覆盖、条件覆盖、判定/条件覆盖、条件组合覆盖和路径覆盖 6 种。</p><ol><li><p>语句覆盖是指选择足够的测试数据，使被测试程序中的每条语句至少执行一次。语句覆盖对程序执行逻辑的覆盖很低，因此一般认为它是很弱的逻辑覆盖。</p></li><li><p>判定覆盖是指设计足够的测试用例，使得被测程序中的每个判定表达式至少获得一次“真”值和“假”值，或者说是程序中的每一个取“真”分支和取“假”分支至少都通过一次，因此判定覆盖也称为分支覆盖。判定覆盖要比语句覆盖更强一些。</p></li><li><p>条件覆盖是指构造一组测试用例，使得每一判定语句中每个逻辑条件的各种可能的值至少满足一次。</p></li><li><p>判定/条件覆盖是指设计足够的测试用例，使得判定中每个条件的所有可能取值（真/假）至少出现一次，并使每个判定本身的判定结果（真/假）也至少出现一次。</p></li><li><p>条件组合覆盖是指设计足够的测试用例，使得每个判定中条件的各种可能值的组合都至少出现一次。满足条件组合覆盖的测试用例是一定满足判定覆盖、条件覆盖和判定/条件覆盖的。</p></li><li><p>路径覆盖是指覆盖被测试程序中所有可能的路径。</p></li></ol><p>白盒测试的原则如下。</p><ul><li>程序模块中的所有独立路径至少执行一次。</li><li>在所有的逻辑判断中，取“真”和取“假”的两种情况至少都能执行一次。</li><li>每个循环都应在边界条件和一般条件下各执行一次。</li><li>测试程序内部数据结构的有效性等。</li></ul><h2 id="软件维护"><a href="#软件维护" class="headerlink" title="软件维护"></a>软件维护</h2><p>软件维护是软件生命周期中的最后一个阶段，处于系统投入生产性运行以后的时期中，因此不属于系统开发过程。</p><p>软件维护主要是指根据需求变化或硬件环境的变化对应用程序进行部分或全部修改。</p><h3 id="可维护性"><a href="#可维护性" class="headerlink" title="可维护性"></a>可维护性</h3><p>软件系统可维护性的评价指标：</p><ul><li>可理解性</li><li>可测试行</li><li>可修改性</li></ul><h3 id="软件文档"><a href="#软件文档" class="headerlink" title="软件文档"></a>软件文档</h3><ul><li>文档是软件可维护性的决定因素。</li><li>在开发阶段必须保证软件具有可维护的特点。</li><li>在软件工程的每一个阶段都应考虑并提高软件的可维护性。</li></ul><h3 id="维护内容"><a href="#维护内容" class="headerlink" title="维护内容"></a>维护内容</h3><ol><li><p>正确性维护是指改正在系统开发阶段已发生而系统测试阶段尚未发现的错误。</p></li><li><p>适应性维护是指使应用软件适应信息技术变化和管理需求变化而进行的修改。</p></li><li><p>完善性维护是为扩充功能和改善性能而进行的修改，主要是指对已有的软件系统增加一些在系统分析和设计阶段中没有规定的功能与性能特征。</p></li><li><p>预防性维护是为了改进应用软件的可靠性和可维护性，为了适应未来的软/硬件环境的变化，应主动增加预防性的新的功能，以使应用系统适应各类变化而不被淘汰。</p></li></ol><h2 id="项目管理"><a href="#项目管理" class="headerlink" title="项目管理"></a>项目管理</h2><h3 id="项目估算"><a href="#项目估算" class="headerlink" title="项目估算"></a>项目估算</h3><h4 id="COCOMO-估算模型"><a href="#COCOMO-估算模型" class="headerlink" title="COCOMO 估算模型"></a>COCOMO 估算模型</h4><ul><li>基本 COCOMO 估算是一个静态单变量模型。</li><li>中级 COCOMO 估算是一个静态多变量模型。</li></ul><h4 id="COCOMOⅡ-估算模型"><a href="#COCOMOⅡ-估算模型" class="headerlink" title="COCOMOⅡ 估算模型"></a>COCOMOⅡ 估算模型</h4><p>COCOMOⅡ 被分为 3 个阶段性模型：</p><ul><li>应用组装模型，估算信息是对象点。</li><li>早期设计阶段模型，估算信息是功能点。</li><li>体系结构阶段模型，估算信息是代码行。</li></ul><h3 id="进度安排"><a href="#进度安排" class="headerlink" title="进度安排"></a>进度安排</h3><h4 id="Gantt-图"><a href="#Gantt-图" class="headerlink" title="Gantt 图"></a>Gantt 图</h4><p>Gantt 图（甘特图）是一种简单的水平条形图，它以日历为基准描述项目任务。水平轴表示日历时间线（如时、天、周、月和年等），每个条形表示一个任务，任务名称垂直地列在左边的列中，图中水平条的起点和终点对应水平轴上的时间，分别表示该任务的开始时间和结束时间，水平条的长度表示完成该任务所持续的时间。当日历中同一时段存在多个水平条时，表示任务之间的并发。</p><p><img lazyload="" alt="20230515171652" data-src="https://img.lisir.me/image/posts/4357767a/20230515171652.png"></p><p>Gantt 图能清晰地描述每个任务从何时开始，到何时结束，任务的进展情况以及各个任务之间的并行性。但是它不能清晰地反映出各任务之间的依赖关系，难以确定整个项目的关键所在，也不能反映计划中有潜力的部分。</p><h4 id="PERT-图"><a href="#PERT-图" class="headerlink" title="PERT 图"></a>PERT 图</h4><p>PERT 图不仅给出了每个任务的开始时间、结束时间和完成该任务所需的时间，还给出了任务之间的关系，即哪些任务完成后才能开始另外一些任务，以及如期完成整个工程的关键路径。图中的松驰时间则反映了完成某些任务是可以推迟其开始时间或延长其所需完成的时间。但是，PERT 图不能反映任务之间的并行关系。</p><h4 id="项目活动图"><a href="#项目活动图" class="headerlink" title="项目活动图"></a>项目活动图</h4><p>下图是一个软件项目的活动图，其中顶点表示项目里程碑，连接顶点的边表示活动，边上的值表示完成活动所需要的时间，没有前驱的顶点是开始，没有后继的顶点是结束。</p><p><img lazyload="" alt="20230516084831" data-src="https://img.lisir.me/image/posts/4357767a/20230516084831.png"></p><p><strong>关键路径：</strong></p><ul><li>从开始到结束的所有路径中，时间最长的一条为关键路径。<ul><li>特点：在关键路径上，所有任务的松弛时间都为 0。</li></ul></li></ul><p><strong>松弛时间：</strong></p><ul><li><p>第一种方法：最晚开始时间 - 最早开始时间。</p></li><li><p>第二种方法：关键路径的总时间 - 包含该任务的任务路径花的时间。</p><ul><li>前提条件：必须不影响该任务以后的任务路径。</li></ul></li></ul><h3 id="风险管理"><a href="#风险管理" class="headerlink" title="风险管理"></a>风险管理</h3><p>软件风险包含两个特性：</p><ul><li>不确定性：指风险可能发生也可能不发生。</li><li>损失：指如果风险发生，就会产生恶性后果。</li></ul><p>三种风险类型：</p><ul><li><p>项目风险威胁到项目计划。项目风险是指预算、进度、人员（聘用职员及组织）、资源、利益相关者、需求等方面的潜在问题以及它们对软件项目的影响。项目复杂度、规模及结构不确定性也属于项目风险因素。</p></li><li><p>技术风险威胁到要开发软件的质量及交付时间。技术风险是指设计、实现、接口、验证和维护等方面的潜在问题。</p></li><li><p>商业风险威胁到要开发软件的生存能力，且常常会危害到项目或产品。</p></li></ul><p>风险预测又称风险估计，它试图从两个方面评估一个风险：</p><ul><li><p>风险发生的可能性或概率。</p></li><li><p>如果风险发生了所产生的后果。</p></li></ul><p>风险控制的目的是辅助项目组建立处理风险的策略。一个有效的策略必须考虑以下问题：</p><ul><li><p>风险避免。主动地避免风险，即在风险发生前分析引起风险的原因，然后采取措施，以避免风险的发生。</p></li><li><p>风险监控。项目管理者应监控某些因素，这些因素可以提供风险是否正在变高或变低的指示。</p></li><li><p>RMMM 计划。评估所预测的风险是否真的发生了；保证正确地实施了各风险的缓解步骤；收集能够用于今后风险分析的信息。</p></li></ul><p>风险显露度 = 风险发生的概率 * 风险发生时带来的项目成本</p><h2 id="软件质量"><a href="#软件质量" class="headerlink" title="软件质量"></a>软件质量</h2><h3 id="质量模型"><a href="#质量模型" class="headerlink" title="质量模型"></a>质量模型</h3><p><img lazyload="" alt="20230516125444" data-src="https://img.lisir.me/image/posts/4357767a/20230516125444.png"></p><h2 id="软件度量"><a href="#软件度量" class="headerlink" title="软件度量"></a>软件度量</h2><p>可靠性、可用性和可维护性是软件的质量属性，软件工程中，用 <code>0~1</code> 之间的数来度量。</p><p>可靠性是指一个系统对于给定的时间间隔内，在给定条件下无失效运作的概率。可以用 <code>MTTF/(1+MTTF)</code> 来度量，其中 <code>MTTF</code> 为平均无故障时间。</p><p>可用性是在给定的时间点上，一个系统能够按照规格说明正确运作的概率。可以用 <code>MTBF/(1+MTBF)</code> 来度量，其中 <code>MTBF</code> 为平均失效间隔时间。</p><p>可维护性是在给定的使用条件下，在规定的时间间隔内，使用规定的过程和资源完成维护活动的概率。可以用 <code>1/(1+MTTR)</code> 来度量，其中 <code>MTTR</code> 为平均修复时间。</p><h3 id="McCabe-度量法"><a href="#McCabe-度量法" class="headerlink" title="McCabe 度量法"></a>McCabe 度量法</h3><p>McCabe 度量法是由 <em>托马斯·麦克凯</em> 提出的一种基于程序控制流的复杂性度量方法。又称环路度量，循环复杂度（Cyclomatic complexity）， 也称为条件复杂度或圈复杂度，是一种软件度量。它认为程序的复杂性很大程度上取决于程序图的复杂性。单一的顺序结构最为简单，循环和选择所构成的环路越多，程序就越复杂。</p><p>根据图论，在一个强连通的有向图 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.05ex;" xmlns="http://www.w3.org/2000/svg" width="1.778ex" height="1.645ex" role="img" focusable="false" viewBox="0 -705 786 727"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D43A" d="M50 252Q50 367 117 473T286 641T490 704Q580 704 633 653Q642 643 648 636T656 626L657 623Q660 623 684 649Q691 655 699 663T715 679T725 690L740 705H746Q760 705 760 698Q760 694 728 561Q692 422 692 421Q690 416 687 415T669 413H653Q647 419 647 422Q647 423 648 429T650 449T651 481Q651 552 619 605T510 659Q492 659 471 656T418 643T357 615T294 567T236 496T189 394T158 260Q156 242 156 221Q156 173 170 136T206 79T256 45T308 28T353 24Q407 24 452 47T514 106Q517 114 529 161T541 214Q541 222 528 224T468 227H431Q425 233 425 235T427 254Q431 267 437 273H454Q494 271 594 271Q634 271 659 271T695 272T707 272Q721 272 721 263Q721 261 719 249Q714 230 709 228Q706 227 694 227Q674 227 653 224Q646 221 643 215T629 164Q620 131 614 108Q589 6 586 3Q584 1 581 1Q571 1 553 21T530 52Q530 53 528 52T522 47Q448 -22 322 -22Q201 -22 126 55T50 252Z"></path></g></g></g></svg></mjx-container> 中，环的个数 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="5.278ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 2333 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D449" d="M52 648Q52 670 65 683H76Q118 680 181 680Q299 680 320 683H330Q336 677 336 674T334 656Q329 641 325 637H304Q282 635 274 635Q245 630 242 620Q242 618 271 369T301 118L374 235Q447 352 520 471T595 594Q599 601 599 609Q599 633 555 637Q537 637 537 648Q537 649 539 661Q542 675 545 679T558 683Q560 683 570 683T604 682T668 681Q737 681 755 683H762Q769 676 769 672Q769 655 760 640Q757 637 743 637Q730 636 719 635T698 630T682 623T670 615T660 608T652 599T645 592L452 282Q272 -9 266 -16Q263 -18 259 -21L241 -22H234Q216 -22 216 -15Q213 -9 177 305Q139 623 138 626Q133 637 76 637H59Q52 642 52 648Z"></path></g><g data-mml-node="mo" transform="translate(769,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(1158,0)"><path data-c="1D43A" d="M50 252Q50 367 117 473T286 641T490 704Q580 704 633 653Q642 643 648 636T656 626L657 623Q660 623 684 649Q691 655 699 663T715 679T725 690L740 705H746Q760 705 760 698Q760 694 728 561Q692 422 692 421Q690 416 687 415T669 413H653Q647 419 647 422Q647 423 648 429T650 449T651 481Q651 552 619 605T510 659Q492 659 471 656T418 643T357 615T294 567T236 496T189 394T158 260Q156 242 156 221Q156 173 170 136T206 79T256 45T308 28T353 24Q407 24 452 47T514 106Q517 114 529 161T541 214Q541 222 528 224T468 227H431Q425 233 425 235T427 254Q431 267 437 273H454Q494 271 594 271Q634 271 659 271T695 272T707 272Q721 272 721 263Q721 261 719 249Q714 230 709 228Q706 227 694 227Q674 227 653 224Q646 221 643 215T629 164Q620 131 614 108Q589 6 586 3Q584 1 581 1Q571 1 553 21T530 52Q530 53 528 52T522 47Q448 -22 322 -22Q201 -22 126 55T50 252Z"></path></g><g data-mml-node="mo" transform="translate(1944,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container> 由以下公式给出：</p><p><mjx-container class="MathJax" jax="SVG" display="true"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="18.302ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 8089.4 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D449" d="M52 648Q52 670 65 683H76Q118 680 181 680Q299 680 320 683H330Q336 677 336 674T334 656Q329 641 325 637H304Q282 635 274 635Q245 630 242 620Q242 618 271 369T301 118L374 235Q447 352 520 471T595 594Q599 601 599 609Q599 633 555 637Q537 637 537 648Q537 649 539 661Q542 675 545 679T558 683Q560 683 570 683T604 682T668 681Q737 681 755 683H762Q769 676 769 672Q769 655 760 640Q757 637 743 637Q730 636 719 635T698 630T682 623T670 615T660 608T652 599T645 592L452 282Q272 -9 266 -16Q263 -18 259 -21L241 -22H234Q216 -22 216 -15Q213 -9 177 305Q139 623 138 626Q133 637 76 637H59Q52 642 52 648Z"></path></g><g data-mml-node="mo" transform="translate(769,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(1158,0)"><path data-c="1D43A" d="M50 252Q50 367 117 473T286 641T490 704Q580 704 633 653Q642 643 648 636T656 626L657 623Q660 623 684 649Q691 655 699 663T715 679T725 690L740 705H746Q760 705 760 698Q760 694 728 561Q692 422 692 421Q690 416 687 415T669 413H653Q647 419 647 422Q647 423 648 429T650 449T651 481Q651 552 619 605T510 659Q492 659 471 656T418 643T357 615T294 567T236 496T189 394T158 260Q156 242 156 221Q156 173 170 136T206 79T256 45T308 28T353 24Q407 24 452 47T514 106Q517 114 529 161T541 214Q541 222 528 224T468 227H431Q425 233 425 235T427 254Q431 267 437 273H454Q494 271 594 271Q634 271 659 271T695 272T707 272Q721 272 721 263Q721 261 719 249Q714 230 709 228Q706 227 694 227Q674 227 653 224Q646 221 643 215T629 164Q620 131 614 108Q589 6 586 3Q584 1 581 1Q571 1 553 21T530 52Q530 53 528 52T522 47Q448 -22 322 -22Q201 -22 126 55T50 252Z"></path></g><g data-mml-node="mo" transform="translate(1944,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g><g data-mml-node="mo" transform="translate(2610.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mi" transform="translate(3666.6,0)"><path data-c="1D45A" d="M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(4766.8,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mi" transform="translate(5767,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(6589.2,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mn" transform="translate(7589.4,0)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g></g></g></svg></mjx-container></p><p>其中，<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="5.278ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 2333 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D449" d="M52 648Q52 670 65 683H76Q118 680 181 680Q299 680 320 683H330Q336 677 336 674T334 656Q329 641 325 637H304Q282 635 274 635Q245 630 242 620Q242 618 271 369T301 118L374 235Q447 352 520 471T595 594Q599 601 599 609Q599 633 555 637Q537 637 537 648Q537 649 539 661Q542 675 545 679T558 683Q560 683 570 683T604 682T668 681Q737 681 755 683H762Q769 676 769 672Q769 655 760 640Q757 637 743 637Q730 636 719 635T698 630T682 623T670 615T660 608T652 599T645 592L452 282Q272 -9 266 -16Q263 -18 259 -21L241 -22H234Q216 -22 216 -15Q213 -9 177 305Q139 623 138 626Q133 637 76 637H59Q52 642 52 648Z"></path></g><g data-mml-node="mo" transform="translate(769,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(1158,0)"><path data-c="1D43A" d="M50 252Q50 367 117 473T286 641T490 704Q580 704 633 653Q642 643 648 636T656 626L657 623Q660 623 684 649Q691 655 699 663T715 679T725 690L740 705H746Q760 705 760 698Q760 694 728 561Q692 422 692 421Q690 416 687 415T669 413H653Q647 419 647 422Q647 423 648 429T650 449T651 481Q651 552 619 605T510 659Q492 659 471 656T418 643T357 615T294 567T236 496T189 394T158 260Q156 242 156 221Q156 173 170 136T206 79T256 45T308 28T353 24Q407 24 452 47T514 106Q517 114 529 161T541 214Q541 222 528 224T468 227H431Q425 233 425 235T427 254Q431 267 437 273H454Q494 271 594 271Q634 271 659 271T695 272T707 272Q721 272 721 263Q721 261 719 249Q714 230 709 228Q706 227 694 227Q674 227 653 224Q646 221 643 215T629 164Q620 131 614 108Q589 6 586 3Q584 1 581 1Q571 1 553 21T530 52Q530 53 528 52T522 47Q448 -22 322 -22Q201 -22 126 55T50 252Z"></path></g><g data-mml-node="mo" transform="translate(1944,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container> 是有向图 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.05ex;" xmlns="http://www.w3.org/2000/svg" width="1.778ex" height="1.645ex" role="img" focusable="false" viewBox="0 -705 786 727"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D43A" d="M50 252Q50 367 117 473T286 641T490 704Q580 704 633 653Q642 643 648 636T656 626L657 623Q660 623 684 649Q691 655 699 663T715 679T725 690L740 705H746Q760 705 760 698Q760 694 728 561Q692 422 692 421Q690 416 687 415T669 413H653Q647 419 647 422Q647 423 648 429T650 449T651 481Q651 552 619 605T510 659Q492 659 471 656T418 643T357 615T294 567T236 496T189 394T158 260Q156 242 156 221Q156 173 170 136T206 79T256 45T308 28T353 24Q407 24 452 47T514 106Q517 114 529 161T541 214Q541 222 528 224T468 227H431Q425 233 425 235T427 254Q431 267 437 273H454Q494 271 594 271Q634 271 659 271T695 272T707 272Q721 272 721 263Q721 261 719 249Q714 230 709 228Q706 227 694 227Q674 227 653 224Q646 221 643 215T629 164Q620 131 614 108Q589 6 586 3Q584 1 581 1Q571 1 553 21T530 52Q530 53 528 52T522 47Q448 -22 322 -22Q201 -22 126 55T50 252Z"></path></g></g></g></svg></mjx-container> 中环路数，<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.986ex" height="1.025ex" role="img" focusable="false" viewBox="0 -442 878 453"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45A" d="M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g></g></g></svg></mjx-container> 是图 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.05ex;" xmlns="http://www.w3.org/2000/svg" width="1.778ex" height="1.645ex" role="img" focusable="false" viewBox="0 -705 786 727"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D43A" d="M50 252Q50 367 117 473T286 641T490 704Q580 704 633 653Q642 643 648 636T656 626L657 623Q660 623 684 649Q691 655 699 663T715 679T725 690L740 705H746Q760 705 760 698Q760 694 728 561Q692 422 692 421Q690 416 687 415T669 413H653Q647 419 647 422Q647 423 648 429T650 449T651 481Q651 552 619 605T510 659Q492 659 471 656T418 643T357 615T294 567T236 496T189 394T158 260Q156 242 156 221Q156 173 170 136T206 79T256 45T308 28T353 24Q407 24 452 47T514 106Q517 114 529 161T541 214Q541 222 528 224T468 227H431Q425 233 425 235T427 254Q431 267 437 273H454Q494 271 594 271Q634 271 659 271T695 272T707 272Q721 272 721 263Q721 261 719 249Q714 230 709 228Q706 227 694 227Q674 227 653 224Q646 221 643 215T629 164Q620 131 614 108Q589 6 586 3Q584 1 581 1Q571 1 553 21T530 52Q530 53 528 52T522 47Q448 -22 322 -22Q201 -22 126 55T50 252Z"></path></g></g></g></svg></mjx-container> 中弧数，<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.357ex" height="1.025ex" role="img" focusable="false" viewBox="0 -442 600 453"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g></g></g></svg></mjx-container> 是图 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.05ex;" xmlns="http://www.w3.org/2000/svg" width="1.778ex" height="1.645ex" role="img" focusable="false" viewBox="0 -705 786 727"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D43A" d="M50 252Q50 367 117 473T286 641T490 704Q580 704 633 653Q642 643 648 636T656 626L657 623Q660 623 684 649Q691 655 699 663T715 679T725 690L740 705H746Q760 705 760 698Q760 694 728 561Q692 422 692 421Q690 416 687 415T669 413H653Q647 419 647 422Q647 423 648 429T650 449T651 481Q651 552 619 605T510 659Q492 659 471 656T418 643T357 615T294 567T236 496T189 394T158 260Q156 242 156 221Q156 173 170 136T206 79T256 45T308 28T353 24Q407 24 452 47T514 106Q517 114 529 161T541 214Q541 222 528 224T468 227H431Q425 233 425 235T427 254Q431 267 437 273H454Q494 271 594 271Q634 271 659 271T695 272T707 272Q721 272 721 263Q721 261 719 249Q714 230 709 228Q706 227 694 227Q674 227 653 224Q646 221 643 215T629 164Q620 131 614 108Q589 6 586 3Q584 1 581 1Q571 1 553 21T530 52Q530 53 528 52T522 47Q448 -22 322 -22Q201 -22 126 55T50 252Z"></path></g></g></g></svg></mjx-container> 中结点数，<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.439ex;" xmlns="http://www.w3.org/2000/svg" width="1.138ex" height="1.439ex" role="img" focusable="false" viewBox="0 -442 503 636"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45D" d="M23 287Q24 290 25 295T30 317T40 348T55 381T75 411T101 433T134 442Q209 442 230 378L240 387Q302 442 358 442Q423 442 460 395T497 281Q497 173 421 82T249 -10Q227 -10 210 -4Q199 1 187 11T168 28L161 36Q160 35 139 -51T118 -138Q118 -144 126 -145T163 -148H188Q194 -155 194 -157T191 -175Q188 -187 185 -190T172 -194Q170 -194 161 -194T127 -193T65 -192Q-5 -192 -24 -194H-32Q-39 -187 -39 -183Q-37 -156 -26 -148H-6Q28 -147 33 -136Q36 -130 94 103T155 350Q156 355 156 364Q156 405 131 405Q109 405 94 377T71 316T59 280Q57 278 43 278H29Q23 284 23 287ZM178 102Q200 26 252 26Q282 26 310 49T356 107Q374 141 392 215T411 325V331Q411 405 350 405Q339 405 328 402T306 393T286 380T269 365T254 350T243 336T235 326L232 322Q232 321 229 308T218 264T204 212Q178 106 178 102Z"></path></g></g></g></svg></mjx-container> 是图 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.05ex;" xmlns="http://www.w3.org/2000/svg" width="1.778ex" height="1.645ex" role="img" focusable="false" viewBox="0 -705 786 727"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D43A" d="M50 252Q50 367 117 473T286 641T490 704Q580 704 633 653Q642 643 648 636T656 626L657 623Q660 623 684 649Q691 655 699 663T715 679T725 690L740 705H746Q760 705 760 698Q760 694 728 561Q692 422 692 421Q690 416 687 415T669 413H653Q647 419 647 422Q647 423 648 429T650 449T651 481Q651 552 619 605T510 659Q492 659 471 656T418 643T357 615T294 567T236 496T189 394T158 260Q156 242 156 221Q156 173 170 136T206 79T256 45T308 28T353 24Q407 24 452 47T514 106Q517 114 529 161T541 214Q541 222 528 224T468 227H431Q425 233 425 235T427 254Q431 267 437 273H454Q494 271 594 271Q634 271 659 271T695 272T707 272Q721 272 721 263Q721 261 719 249Q714 230 709 228Q706 227 694 227Q674 227 653 224Q646 221 643 215T629 164Q620 131 614 108Q589 6 586 3Q584 1 581 1Q571 1 553 21T530 52Q530 53 528 52T522 47Q448 -22 322 -22Q201 -22 126 55T50 252Z"></path></g></g></g></svg></mjx-container> 中强连通分量个数。在一个程序中，从程序图的入口点总能到达图中任何一个结点，因此，程序总是连通的，但不是强连通的。为了使图成为强连通图，从图的出口点到入口点加一条用虚线表示的有向边，使图成为强连通图。这样就可以使用上式计算环路复杂性了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;软件工程是指应用计算机科学、数学及管理科学等原理，以工程化的原则和方法来解决软件问题的工程，其目的是提高软件生产率、提高软件质量、降低软件成本。&lt;/p&gt;</summary>
    
    
    
    <category term="证书考试" scheme="https://lisir.me/hexo-theme-keep/categories/%E8%AF%81%E4%B9%A6%E8%80%83%E8%AF%95/"/>
    
    
    <category term="软考" scheme="https://lisir.me/hexo-theme-keep/tags/%E8%BD%AF%E8%80%83/"/>
    
    <category term="软件设计师" scheme="https://lisir.me/hexo-theme-keep/tags/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/"/>
    
    <category term="软件工程" scheme="https://lisir.me/hexo-theme-keep/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>编程语言 | Java</title>
    <link href="https://lisir.me/hexo-theme-keep/posts/976385a6/"/>
    <id>https://lisir.me/hexo-theme-keep/posts/976385a6/</id>
    <published>2023-05-13T13:25:26.000Z</published>
    <updated>2024-10-04T12:26:58.000Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="/hexo-theme-keep/posts/f9e936dc/">Java | 类的五大成员</a></li><li><a href="/hexo-theme-keep/posts/3459c33c/">Java | 异常处理</a></li><li><a href="/hexo-theme-keep/posts/9f0878d8/">Java | 常用类</a></li><li><a href="/hexo-theme-keep/posts/c7f47f99/">Java | 集合框架</a></li><li><a href="/hexo-theme-keep/posts/62ea5aff/">Java | 泛型</a></li></ul><span id="more"></span><hr>]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;/hexo-theme-keep/posts/f9e936dc/&quot;&gt;Java | 类的五大成员&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/hexo-theme-keep/posts/3459c33c/&quot;&gt;Java | 异常处理&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/hexo-theme-keep/posts/9f0878d8/&quot;&gt;Java | 常用类&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/hexo-theme-keep/posts/c7f47f99/&quot;&gt;Java | 集合框架&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/hexo-theme-keep/posts/62ea5aff/&quot;&gt;Java | 泛型&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="编程语言" scheme="https://lisir.me/hexo-theme-keep/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="Java" scheme="https://lisir.me/hexo-theme-keep/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>软件设计师 | 结构化开发</title>
    <link href="https://lisir.me/hexo-theme-keep/posts/b68dcfb1/"/>
    <id>https://lisir.me/hexo-theme-keep/posts/b68dcfb1/</id>
    <published>2023-05-13T11:29:21.000Z</published>
    <updated>2024-09-02T06:10:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>结构化方法由结构化分析、结构化设计、结构化程序设计构成，它是一种面向数据流的开发方法。</p><span id="more"></span><hr><h2 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h2><p>模块在程序中是数据说明、可执行语句等程序对象的集合，或者是单独命名和编址的元素，例如高级语言中的过程、函数和子程序等。在软件的体系结构中，模块是可组合、分解和更换的单元。</p><p>模块化是指将一个待开发的软件分解成若干个小的简单部分，每个模块可独立地开发、测试，最后组装成完整的程序。这是一种复杂问题“分而治之”的原则。模块化的目的是使程序的结构清晰，容易阅读、理解、测试和修改。</p><h2 id="模块独立"><a href="#模块独立" class="headerlink" title="模块独立"></a>模块独立</h2><p>模块独立是指每个模块完成一个相对独立的特定子功能，并且与其他模块之间的联系简单。衡量模块独立程度的标准有两个：耦合性和内聚性。</p><p>耦合性和内聚性是模块独立性的两个定性标准，在将软件系统划分模块时，应尽量做到高内聚、低耦合，提高模块的独立性。</p><h3 id="耦合"><a href="#耦合" class="headerlink" title="耦合"></a>耦合</h3><p>耦合是模块之间的相对独立性（互相连接的紧密程度）的度量。耦合取决于各个模块之间接口的复杂程度、调用模块的方式以及通过接口的信息类型等。一般模块之间可能的耦合方式有 7 种类型，如下图所示。</p><p><img                         lazyload                       alt="image"                       data-src="https://img.lisir.me/image/posts/b68dcfb1/20230513210238.png"                        alt="20230513210238"                 ></p><ul><li><p>无直接耦合：指两个模块之间没有直接的关系，它们分别从属于不同模块的控制与调用，它们之间不传递任何信息。因此，模块间耦合性最弱，模块独立性最高。</p></li><li><p>数据耦合：指两个模块之间有调用关系，传递的是简单的数据值，相当于高级语言中的值传递。</p></li><li><p>标记耦合：指两个模块之间传递的是数据结构。</p></li><li><p>控制耦合：指一个模块调用另一个模块时，传递的是控制变量，被调用模块通过该控制变量的值有选择地执行模块内的某一功能。因此，被调用模块应具有多个功能，哪个功能起作用受调用模块控制。</p></li><li><p>外部耦合：模块间通过软件之外的环境联结（如 I&#x2F;O 将模块耦合到特定的设备、格式、通信协议上）时称为外部耦合。</p></li><li><p>公共耦合：指通过一个公共数据环境相互作用的那些模块间的耦合。</p></li><li><p>内容耦合：当一个模块直接使用另一个模块的内部数据，或通过非正常入口转入另一个模块内部时，这种模块之间的耦合称为内容耦合。</p></li></ul><h3 id="内聚"><a href="#内聚" class="headerlink" title="内聚"></a>内聚</h3><p>内聚是对一个模块内部各个元素彼此结合的紧密程度的度量。一个内聚程度高的模块（在理想情况下）应当只做一件事。一般模块的内聚性分为 7 种类型，如下图所示。</p><p><img                         lazyload                       alt="image"                       data-src="https://img.lisir.me/image/posts/b68dcfb1/20230513210311.png"                        alt="20230513210311"                 ></p><ul><li><p>偶然内聚：也称巧合内聚，指一个模块内的各处理元素之间没有任何联系。</p></li><li><p>逻辑内聚：指模块内执行若干个逻辑上相似的功能，通过参数确定该模块完成哪一个功能。</p></li><li><p>时间内聚：把需要同时执行的动作组合在一起形成的模块称为时间内聚模块。</p></li><li><p>过程内聚：指一个模块完成多个任务，这些任务必须按指定的过程执行。</p></li><li><p>通信内聚：指模块内的所有处理元素都在同一个数据结构上操作，或者各处理使用相同的输入数据或者产生相同的输出数据。</p></li><li><p>顺序内聚：指一个模块中的各个处理元素都密切相关于同一功能且必须顺序执行，前一功能元素的输出就是下一功能元素的输入。</p></li><li><p>功能内聚：这是最强的内聚，指模块内的所有元素共同作用完成一个功能，缺一不可。</p></li></ul><h2 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h2><p>为保证总体结构设计顺利完成，应遵循以下几条原则。</p><ul><li><p>分解-协调原则。整个系统是一个整体，具有整体目的和功能，但这些目的和功能的实现又是由相互联系的各个组成部分共同工作的结果。解决复杂问题的一个很重要的原则就是把它分解成多个小问题分别处理，在处理过程中根据系统总体要求协调各部门的关系。</p></li><li><p>自顶向下的原则。首先抓住系统总的功能目的，然后逐层分解，即先确定上层模块的功能，再确定下层模块的功能</p></li><li><p>信息隐蔽、抽象的原则。上层模块只规定下层模块做什么和所属模块间的协调关系但不规定怎么做，以保证各模块的相对独立性和内部结构的合理性，使得模块与模块之间层次分明，易于理解、实施和维护。</p></li><li><p>一致性原则。要保证整个软件设计过程中具有统一的规范、统一的标准和统一的文件模式等。</p></li><li><p>明确性原则。每个模块必须功能明确、接口明确，消除多重功能和无用接口。</p></li><li><p>模块之间的耦合尽可能小，模块的内聚度尽可能高。</p></li><li><p>模块的扇入系数和扇出系数要合理。一个模块直接调用其他模块的个数称为模块的扇出系数；反之，一个模块被其他模块调用时，直接调用它的模块个数称为模块的扇入系数。模块的扇入、扇出系数必须适当。经验表明，一个设计得好的系统的平均扇入、扇出系数通常是 3 或 4，一般不应超过 7，否则会引起出错概率的增大。但菜单调用型模块的扇入与扇出系数可以大一些，公用模块的扇入系数可以大一些。</p></li><li><p>模块的规模适当。过大的模块常常使系统分解得不充分，其内部可能包含了若干部分的功能，因此有必要进一步把原有的模块分解成若干功能尽可能单一的模块。但分解也必须适度，因为过小的模块有可能降低模块的独立性，造成系统接口的复杂性。</p></li><li><p>模块的作用范围应该在其控制范围之内。</p></li></ul><h2 id="系统文档"><a href="#系统文档" class="headerlink" title="系统文档"></a>系统文档</h2><p>信息系统的文档是系统建设过程的“痕迹”，是系统维护人员的指南，是开发人员与用户交流的工具。规范的文档意味着系统是按照工程化开发的，意味着信息系统的质量有了形式上的保障。文档的欠缺、文档的随意性和文档的不规范，极有可能导致原来的开发人员流动以后，系统不可维护、不可升级，变成了一个没有扩展性、没有生命力的系统。</p><p>对文档在系统开发人员、项目管理人员、系统维护人员、系统评价人员以及用户之间的多种作用总结如下。</p><ul><li><p>用户与系统分析人员在系统规划和系统分析阶段通过文档进行沟通。这里的文档主要包括可行性研究报告、总体规划报告、系统开发合同和系统方案说明书等。有了文档，用户就能依次对系统分析师是否正确理解了系统的需求进行评价，如不正确，可以在已有文档的基础上进行修正。</p></li><li><p>系统开发人员与项目管理人员通过文档在项目期内进行沟通。这里的文档主要有系统开发计划（包括工作任务分解表、PERT 图、甘特图和预算分配表等）、系统开发月报以及系统开发总结报告等项目管理文件。有了这些文档，不同阶段之间的开发人员就可以进行工作的顺利交接，同时还能降低因为人员流动带来的风险，因为接替人员可以根据文档理解前面人员的设计思路或开发思路。</p></li><li><p>系统测试人员与系统开发人员通过文档进行沟通。系统测试人员可以根据系统方案说明书、系统开发合同、系统设计说明书和测试计划等文档对系统开发人员所开发的系统进行测试。系统测试人员再将评估结果撰写成系统测试报告。</p></li><li><p>系统开发人员与用户在系统运行期间进行沟通。用户通过系统开发人员撰写的文档运行系统。这里的文档主要是用户手册和操作指南。</p></li><li><p>系统开发人员与系统维护人员通过文档进行沟通。这里的文档主要有系统设计说明书和系统开发总结报告。有的开发总结报告写得很详细，分为研制报告、技术报告和技术手册 3 个文档，其中的技术手册记录了系统开发过程中的各种主要技术细节。这样，即使系统维护人员不是原来的开发人员，也可以在这些文档的基础上进行系统的维护与升级。</p></li><li><p>用户与维修人员在运行维护期间进行沟通。用户在使用信息系统的过程中，将运行过程中的问题进行记载，形成系统运行报告和维护修改建议。系统维护人员根据维护修改建议以及系统开发人员留下的技术手册等文档对系统进行维护和升级。</p></li></ul><h2 id="数据字典"><a href="#数据字典" class="headerlink" title="数据字典"></a>数据字典</h2><p>数据流图描述了系统的分解，但没有对图中各成分进行说明。数据字典就是为数据流图中的每个数据流、文件、加工，以及组成数据流或文件的数据项做出说明。其中，对加工的描述称为“小说明”，也可以称为“加工逻辑说明”。</p><h3 id="数据字典的内容"><a href="#数据字典的内容" class="headerlink" title="数据字典的内容"></a>数据字典的内容</h3><p>数据字典有以下 4 类条目：数据流、数据项、数据存储和基本加工。数据项是组成数据流和数据存储的最小元素。源点、终点不在系统之内，故一般不在字典中说明。</p><h3 id="数据词典管理"><a href="#数据词典管理" class="headerlink" title="数据词典管理"></a>数据词典管理</h3><p>词典管理主要是把词典条目按照某种格式组织后存储在词典中，并提供排序、查找和统计等功能。如果数据流条目包含了来源和去向，文件条目包含了读文件和写文件，还可以检查数据词典与数据流图的一致性。</p><h3 id="加工逻辑的描述"><a href="#加工逻辑的描述" class="headerlink" title="加工逻辑的描述"></a>加工逻辑的描述</h3><p>加工逻辑也称为“小说明”。常用的加工逻辑描述方法有结构化语言、判定表和判定树 3 种。</p><p>结构化语言通常可分为内层和外层。外层有严格的语法，内层的语法比较灵活，可以接近于自然语言的描述。外层用来描述控制结构，采用顺序、选择和重复 3 种基本结构。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;结构化方法由结构化分析、结构化设计、结构化程序设计构成，它是一种面向数据流的开发方法。&lt;/p&gt;</summary>
    
    
    
    <category term="证书考试" scheme="https://lisir.me/hexo-theme-keep/categories/%E8%AF%81%E4%B9%A6%E8%80%83%E8%AF%95/"/>
    
    
    <category term="软考" scheme="https://lisir.me/hexo-theme-keep/tags/%E8%BD%AF%E8%80%83/"/>
    
    <category term="软件设计师" scheme="https://lisir.me/hexo-theme-keep/tags/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/"/>
    
    <category term="结构化开发" scheme="https://lisir.me/hexo-theme-keep/tags/%E7%BB%93%E6%9E%84%E5%8C%96%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>软件设计师 | 操作系统</title>
    <link href="https://lisir.me/hexo-theme-keep/posts/eb3d0f85/"/>
    <id>https://lisir.me/hexo-theme-keep/posts/eb3d0f85/</id>
    <published>2023-05-12T07:40:09.000Z</published>
    <updated>2024-09-02T06:10:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>计算机系统由硬件和软件两部分组成。通常把未配置软件的计算机称为裸机。直接使用裸机不仅不方便，而且将严重降低工作效率和机器的利用率。操作系统（Operating System）目的是为了填补人与机器之间的鸿沟，即建立用户与计算机之间的接口，而为裸机配置的一种系统软件。</p><span id="more"></span><hr><p><strong>操作系统在计算机系统中的地位：</strong></p><p><img lazyload="" alt="20230512155330" data-src="https://img.lisir.me/image/posts/eb3d0f85/20230512155330.png"></p><h2 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h2><p>进程管理也称处理机管理。在多道程序批处理系统和分时系统中有多个并发执行的程序，为了描述系统中程序执行时动态变化的过程引入了进程。进程是资源分配和独立运行的基本单位。进程管理重点需要研究诸进程之间的并发特性，以及进程之间相互合作与资源竞争产生的问题。</p><h3 id="程序与进程"><a href="#程序与进程" class="headerlink" title="程序与进程"></a>程序与进程</h3><h4 id="程序顺序执行的特征"><a href="#程序顺序执行的特征" class="headerlink" title="程序顺序执行的特征"></a>程序顺序执行的特征</h4><p>前趋图是一个有向无循环图，由结点和有向边组成，结点代表各程序段的操作，而结点间的有向边表示两个程序段操作之间存在的前趋关系。</p><p>例如，下图三个程序段，其中输入是计算的前驱（计算是输入的后继），输入结束才能进行计算；计算是输出的前驱，计算结束才能进行输出。</p><p><img lazyload="" alt="20230512161226" data-src="https://img.lisir.me/image/posts/eb3d0f85/20230512161226.png"></p><p>序顺序执行时的主要特征包括顺序性、封闭性和可再现性。</p><h4 id="程序并发执行的特征"><a href="#程序并发执行的特征" class="headerlink" title="程序并发执行的特征"></a>程序并发执行的特征</h4><p>若在计算机系统中采用多道程序设计技术，则主存中的多道程序可处于并发执行状态。对于上述有 3 个程序段的作业类，虽然每个作业有前趋关系的各程序段不能在 CPU 和输入/输出各部件并行执行，但是同一个作业内没有前超关系的程序段或不同作业的程序段可以分别在 CPU 和各输入/输出部件上并行执行。</p><p>下图为三个作业的各程序段并发执行的前驱图，从图中可以看出，<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.339ex;" xmlns="http://www.w3.org/2000/svg" width="1.983ex" height="1.885ex" role="img" focusable="false" viewBox="0 -683 876.6 833"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D43C" d="M43 1Q26 1 26 10Q26 12 29 24Q34 43 39 45Q42 46 54 46H60Q120 46 136 53Q137 53 138 54Q143 56 149 77T198 273Q210 318 216 344Q286 624 286 626Q284 630 284 631Q274 637 213 637H193Q184 643 189 662Q193 677 195 680T209 683H213Q285 681 359 681Q481 681 487 683H497Q504 676 504 672T501 655T494 639Q491 637 471 637Q440 637 407 634Q393 631 388 623Q381 609 337 432Q326 385 315 341Q245 65 245 59Q245 52 255 50T307 46H339Q345 38 345 37T342 19Q338 6 332 0H316Q279 2 179 2Q143 2 113 2T65 2T43 1Z"></path></g><g data-mml-node="mn" transform="translate(473,-150) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g></g></g></g></svg></mjx-container> 与 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.339ex;" xmlns="http://www.w3.org/2000/svg" width="2.605ex" height="1.934ex" role="img" focusable="false" viewBox="0 -705 1151.6 855"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D436" d="M50 252Q50 367 117 473T286 641T490 704Q580 704 633 653Q642 643 648 636T656 626L657 623Q660 623 684 649Q691 655 699 663T715 679T725 690L740 705H746Q760 705 760 698Q760 694 728 561Q692 422 692 421Q690 416 687 415T669 413H653Q647 419 647 422Q647 423 648 429T650 449T651 481Q651 552 619 605T510 659Q484 659 454 652T382 628T299 572T226 479Q194 422 175 346T156 222Q156 108 232 58Q280 24 350 24Q441 24 512 92T606 240Q610 253 612 255T628 257Q648 257 648 248Q648 243 647 239Q618 132 523 55T319 -22Q206 -22 128 53T50 252Z"></path></g><g data-mml-node="mn" transform="translate(748,-150) scale(0.707)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g></g></g></g></svg></mjx-container> 并行执行；<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.375ex;" xmlns="http://www.w3.org/2000/svg" width="1.983ex" height="1.92ex" role="img" focusable="false" viewBox="0 -683 876.6 848.6"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D43C" d="M43 1Q26 1 26 10Q26 12 29 24Q34 43 39 45Q42 46 54 46H60Q120 46 136 53Q137 53 138 54Q143 56 149 77T198 273Q210 318 216 344Q286 624 286 626Q284 630 284 631Q274 637 213 637H193Q184 643 189 662Q193 677 195 680T209 683H213Q285 681 359 681Q481 681 487 683H497Q504 676 504 672T501 655T494 639Q491 637 471 637Q440 637 407 634Q393 631 388 623Q381 609 337 432Q326 385 315 341Q245 65 245 59Q245 52 255 50T307 46H339Q345 38 345 37T342 19Q338 6 332 0H316Q279 2 179 2Q143 2 113 2T65 2T43 1Z"></path></g><g data-mml-node="mn" transform="translate(473,-150) scale(0.707)"><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z"></path></g></g></g></g></svg></mjx-container>、<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.339ex;" xmlns="http://www.w3.org/2000/svg" width="2.605ex" height="1.934ex" role="img" focusable="false" viewBox="0 -705 1151.6 855"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D436" d="M50 252Q50 367 117 473T286 641T490 704Q580 704 633 653Q642 643 648 636T656 626L657 623Q660 623 684 649Q691 655 699 663T715 679T725 690L740 705H746Q760 705 760 698Q760 694 728 561Q692 422 692 421Q690 416 687 415T669 413H653Q647 419 647 422Q647 423 648 429T650 449T651 481Q651 552 619 605T510 659Q484 659 454 652T382 628T299 572T226 479Q194 422 175 346T156 222Q156 108 232 58Q280 24 350 24Q441 24 512 92T606 240Q610 253 612 255T628 257Q648 257 648 248Q648 243 647 239Q618 132 523 55T319 -22Q206 -22 128 53T50 252Z"></path></g><g data-mml-node="mn" transform="translate(748,-150) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g></g></g></g></svg></mjx-container> 与 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.339ex;" xmlns="http://www.w3.org/2000/svg" width="2.44ex" height="1.885ex" role="img" focusable="false" viewBox="0 -683 1078.6 833"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D443" d="M287 628Q287 635 230 637Q206 637 199 638T192 648Q192 649 194 659Q200 679 203 681T397 683Q587 682 600 680Q664 669 707 631T751 530Q751 453 685 389Q616 321 507 303Q500 302 402 301H307L277 182Q247 66 247 59Q247 55 248 54T255 50T272 48T305 46H336Q342 37 342 35Q342 19 335 5Q330 0 319 0Q316 0 282 1T182 2Q120 2 87 2T51 1Q33 1 33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM645 554Q645 567 643 575T634 597T609 619T560 635Q553 636 480 637Q463 637 445 637T416 636T404 636Q391 635 386 627Q384 621 367 550T332 412T314 344Q314 342 395 342H407H430Q542 342 590 392Q617 419 631 471T645 554Z"></path></g><g data-mml-node="mn" transform="translate(675,-150) scale(0.707)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g></g></g></g></svg></mjx-container> 并行执行；<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.375ex;" xmlns="http://www.w3.org/2000/svg" width="2.605ex" height="1.97ex" role="img" focusable="false" viewBox="0 -705 1151.6 870.6"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D436" d="M50 252Q50 367 117 473T286 641T490 704Q580 704 633 653Q642 643 648 636T656 626L657 623Q660 623 684 649Q691 655 699 663T715 679T725 690L740 705H746Q760 705 760 698Q760 694 728 561Q692 422 692 421Q690 416 687 415T669 413H653Q647 419 647 422Q647 423 648 429T650 449T651 481Q651 552 619 605T510 659Q484 659 454 652T382 628T299 572T226 479Q194 422 175 346T156 222Q156 108 232 58Q280 24 350 24Q441 24 512 92T606 240Q610 253 612 255T628 257Q648 257 648 248Q648 243 647 239Q618 132 523 55T319 -22Q206 -22 128 53T50 252Z"></path></g><g data-mml-node="mn" transform="translate(748,-150) scale(0.707)"><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z"></path></g></g></g></g></svg></mjx-container> 与 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.339ex;" xmlns="http://www.w3.org/2000/svg" width="2.44ex" height="1.885ex" role="img" focusable="false" viewBox="0 -683 1078.6 833"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D443" d="M287 628Q287 635 230 637Q206 637 199 638T192 648Q192 649 194 659Q200 679 203 681T397 683Q587 682 600 680Q664 669 707 631T751 530Q751 453 685 389Q616 321 507 303Q500 302 402 301H307L277 182Q247 66 247 59Q247 55 248 54T255 50T272 48T305 46H336Q342 37 342 35Q342 19 335 5Q330 0 319 0Q316 0 282 1T182 2Q120 2 87 2T51 1Q33 1 33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM645 554Q645 567 643 575T634 597T609 619T560 635Q553 636 480 637Q463 637 445 637T416 636T404 636Q391 635 386 627Q384 621 367 550T332 412T314 344Q314 342 395 342H407H430Q542 342 590 392Q617 419 631 471T645 554Z"></path></g><g data-mml-node="mn" transform="translate(675,-150) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g></g></g></g></svg></mjx-container> 并行执行。</p><p><img lazyload="" alt="20230512165725" data-src="https://img.lisir.me/image/posts/eb3d0f85/20230512165725.png"></p><p><strong>程序并发执行时的特征如下：</strong></p><ul><li>失去了程序的封闭性。</li><li>程序和机器的执行程序的活动不再一一对应。</li><li>并发程序间的相互制约性。</li></ul><h3 id="进程的状态"><a href="#进程的状态" class="headerlink" title="进程的状态"></a>进程的状态</h3><h4 id="三态模型"><a href="#三态模型" class="headerlink" title="三态模型"></a>三态模型</h4><p>在多道程序系统中，进程在处理器上交替运行，状态也不断地发生变化，因此进程一般有 3 种基本状态：运行、就绪和阻塞。下图显示了进程基本状态及其转换，也称三态模型。</p><p><img lazyload="" alt="20230512172021" data-src="https://img.lisir.me/image/posts/eb3d0f85/20230512172021.png"></p><ol><li>运行：当一个进程在处理机上运行时，则称该进程处于运行状态。显然，对于单处理机系统，处于运行状态的进程只有一个。</li><li>就绪：一个进程获得了除处理机外的一切所需资源，一旦得到处理机即可运行，则称此进程处于就绪状态。</li><li>阻塞：阻塞也称等待或睡眠状态，一个进程正在等待某一事件发生（例如请求 I/O 等待 I/O 完成等）而暂时停止运行，这时即使把处理机分配给进程也无法运行，故称该进程处于阻塞状态。</li></ol><h4 id="五态模型"><a href="#五态模型" class="headerlink" title="五态模型"></a>五态模型</h4><p>事实上，对于一个实际的系统，进程的状态及其转换更复杂。例如，引入新建态和终止态构成了进程的五态模型，如下图所示：</p><p><img lazyload="" alt="20230512184840" data-src="https://img.lisir.me/image/posts/eb3d0f85/20230512184840.png"></p><p>其中，新建态对应于进程刚刚被创建时没有被提交的状态，并等待系统完成创建进程的所有必要信息。因为创建进程时分为两个阶段，第一个阶段为一个新进程创建必要的管理信息，第二个阶段让该进程进入就绪状态。由于有了新建态操作系统，往往可以根据系统的性能和主存容量的限制推退新建态进程的提交。</p><h3 id="进程中的通信"><a href="#进程中的通信" class="headerlink" title="进程中的通信"></a>进程中的通信</h3><p>在多道程序环境的系统中存在多个可以并发执行的进程，故进程间必然存在资源共享和相互合作的问题。进程通信是指各个进程交换信息的过程。</p><h4 id="同步与互斥"><a href="#同步与互斥" class="headerlink" title="同步与互斥"></a>同步与互斥</h4><p>同步是合作进程间的直接制约问题，互斥是申请临界资源进程间的间接制约问题。</p><ol><li><p>进程间的同步</p><p> 在计算机系统中，多个进程可以并发执行，每个进程都以各自独立的、不可预知的速度向前推进，但是需要在某些确定点上协调相互合作进程间的工作。例如，进程 A 向缓冲区送数据，进程 B 从缓冲区取数据加工，当进程 B 要取数据加工时，必须是进程 A 完成了向缓冲区送数据的操作，否则进程 B 必须停下来等待进程 A 的操作结束。</p><p> 可见，所谓进程间的同步是指在系统中一些需要相互合作，协同工作的进程，这样的相互联系称为进程的同步。</p></li><li><p>进程间的互斥</p><p> 进程的互斥是指系统中多个进程因争用临界资源而互斥执行。在多道程序系统环境中，各进程可以共享各类资源，但有些资源一次只能供一个进程使用，称为临界资源（Critical Resource，CR），如打印机、共享变量和表格等。</p></li><li><p>临界区管理的原则</p><p> 临界区（Critical Section，CS）是进程中对临界资源实施操作的那段程序。</p></li><li><p>对互斥临界区管理的 4 条原则如下</p><ul><li>有空即进：当无进程处于临界区时，允许进程进入临界区，并且只能在临界区运行有限的时间。</li><li>无空则等：当有一个进程在临界区时，其他欲进入临界区的进程必须等待，以保证进程互斥地访问临界资源。</li><li>有限等待：对于要求访问临界资源的进程，应保证进程能在有限的时间进入临界区，以免陷入“机饿”状态。</li><li>让权等待：当进程不能进入自己的临界区时，应立即释放处理机，以免进程陷入忙等状态。</li></ul></li></ol><h4 id="信号量机制"><a href="#信号量机制" class="headerlink" title="信号量机制"></a>信号量机制</h4><p>信号量机制主要有整型信号量、记录型信号量和信号量集机制。</p><p><strong>整型信号量与 PV 操作：</strong></p><p>信号量是一个整型变量，根据控制对象的不同被赋予不同的值。信号量分为如下两类：</p><ul><li>公用信号量：实现进程间的互斥，初值为 1 或资源的数目。</li><li>私用信号量：实现进程间的同步，初值为 0 或某个正整数。</li></ul><p>信号量 S 的物理意义：<code>S &gt;= 0</code> 表示某资源的可用数，若 <code>S &lt; 0</code>，则其绝对值表示阻塞队列中等待该资源的进程数。</p><p>对于系统中的每个进程，其工作的正确与否不仅取决于它自身的正确性，而且与它在执行中能否与其他相关进程正确地实施同步互异有关。PV 操作是实现进程同步与互斥的常用方法。P 操作和 V 操作是低级通信原语，在执行期间不可分割。其中，P 操作表示申请一个资源，V 操作表示释放一个资源。</p><ul><li><p>P 操作的定义：<code>S = S - 1</code>，若 <code>S &gt;= 0</code>，则执行 P 操作的进程继续执行；若 <code>S &lt; 0</code>，则置该进程为阻塞状态（因为无可用资源），并将其插入阻塞队列。</p></li><li><p>V 操作的定义：<code>S = S + 1</code>，若 <code>S &gt; 0</code>，则执行 V 操作的进程继续执行；若 <code>S &lt;= 0</code>，则从阻塞状态唤醒一个进程，并将其插入就络队列，然后执行 V 操作的进程继续。</p></li></ul><p><strong>利用 PV 操作实现进程的互斥：</strong></p><p>令信号量 mutex 的初值为 1，当进入临界区时执行 P 操作，退出临界区时执行 V 操作。</p><p><strong>利用 PV 操作实现进程的同步：</strong></p><p>进程的同步是由于进程间合作引起的相互制约的问题，要实现进程的同步可用一个信号量与消息联系起来，当信号量的值为 0 时表示希望的消息未产生，当信号量的值为非 0 时表示希望的消息已经存在。假定用信号量 S 表示某条消息，进程可以通过调用 P 操作测试消息是否到达，调用 V 操作通知消息已准备好。最典型的同步问题是单缓冲区的生产者和消费者的同步问题。</p><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>在计算机系统中有许多互斥资源（如磁带机、打印机和绘图仪等）或软件资源（如进程表、临界区等），若两个进程同时使用打印机，或同时进入临界区必然会出现问题。所谓死锁，是指两个以上的进程互相都要求对方已经占有的资源导致无法继续运行下去的现象。</p><p>当有 n 个进程、m 个资源、且每个进程所需要的资源数为 k，并且系统采用的分配策略是轮流地为每个进程分配资源时，判断是否会发生死锁的公式如下：</p><p><mjx-container class="MathJax" jax="SVG" display="true"><svg style="vertical-align: -0.452ex;" xmlns="http://www.w3.org/2000/svg" width="21.995ex" height="2.149ex" role="img" focusable="false" viewBox="0 -750 9721.9 950"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45A" d="M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(1155.8,0)"><path data-c="2265" d="M83 616Q83 624 89 630T99 636Q107 636 253 568T543 431T687 361Q694 356 694 346T687 331Q685 329 395 192L107 56H101Q83 58 83 76Q83 77 83 79Q82 86 98 95Q117 105 248 167Q326 204 378 228L626 346L360 472Q291 505 200 548Q112 589 98 597T83 616ZM84 -118Q84 -108 99 -98H678Q694 -104 694 -118Q694 -130 679 -138H98Q84 -131 84 -118Z"></path></g><g data-mml-node="mi" transform="translate(2211.6,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(3033.8,0)"><path data-c="2217" d="M229 286Q216 420 216 436Q216 454 240 464Q241 464 245 464T251 465Q263 464 273 456T283 436Q283 419 277 356T270 286L328 328Q384 369 389 372T399 375Q412 375 423 365T435 338Q435 325 425 315Q420 312 357 282T289 250L355 219L425 184Q434 175 434 161Q434 146 425 136T401 125Q393 125 383 131T328 171L270 213Q283 79 283 63Q283 53 276 44T250 35Q231 35 224 44T216 63Q216 80 222 143T229 213L171 171Q115 130 110 127Q106 124 100 124Q87 124 76 134T64 161Q64 166 64 169T67 175T72 181T81 188T94 195T113 204T138 215T170 230T210 250L74 315Q65 324 65 338Q65 353 74 363T98 374Q106 374 116 368T171 328L229 286Z"></path></g><g data-mml-node="mi" transform="translate(3756,0)"><text data-variant="italic" transform="scale(1,-1)" font-size="884px" font-family="serif" font-style="italic">（</text></g><g data-mml-node="mi" transform="translate(4756,0)"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"></path></g><g data-mml-node="mo" transform="translate(5499.2,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mn" transform="translate(6499.4,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="mi" transform="translate(6999.4,0)"><text data-variant="italic" transform="scale(1,-1)" font-size="884px" font-family="serif" font-style="italic">）</text></g><g data-mml-node="mo" transform="translate(8221.7,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mn" transform="translate(9221.9,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g></g></g></svg></mjx-container></p><p>为真就不会发生死锁、为假就会发生死锁。</p><h4 id="死锁的处理"><a href="#死锁的处理" class="headerlink" title="死锁的处理"></a>死锁的处理</h4><p>死锁的处理策略主要有4种：驼鸟策略（即不理联策略）、预防策略、避免策略和检测与解除死锁。</p><p>死锁预防是设法破坏产生死锁的 4 个必要条件之一，严格防止死锁的产生。死锁避免则不那么严格地限制产生死锁的必要条件。最著名的死锁避免算法是 Dijkstra 提出的银行家算法死锁避免算法需要很大的系统开销。</p><p>银行家算法对于进程发出的每一个系统可以满足的资源请求命令加以检测，如果发现分配资源后系统进入不安全状态，则不予分配；若分配资源后系统仍处于安全状态，则实施分配。与死锁预防策略相比，它提高了资源的利用率，但检测分配资源后系统是否安全增加了系统开销。</p><p>所谓安全状态，是指系统能按某种顺序如 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.439ex;" xmlns="http://www.w3.org/2000/svg" width="18.294ex" height="1.984ex" role="img" focusable="false" viewBox="0 -683 8085.9 877"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="3C" d="M694 -11T694 -19T688 -33T678 -40Q671 -40 524 29T234 166L90 235Q83 240 83 250Q83 261 91 266Q664 540 678 540Q681 540 687 534T694 519T687 505Q686 504 417 376L151 250L417 124Q686 -4 687 -5Q694 -11 694 -19Z"></path></g><g data-mml-node="msub" transform="translate(1055.8,0)"><g data-mml-node="mi"><path data-c="1D443" d="M287 628Q287 635 230 637Q206 637 199 638T192 648Q192 649 194 659Q200 679 203 681T397 683Q587 682 600 680Q664 669 707 631T751 530Q751 453 685 389Q616 321 507 303Q500 302 402 301H307L277 182Q247 66 247 59Q247 55 248 54T255 50T272 48T305 46H336Q342 37 342 35Q342 19 335 5Q330 0 319 0Q316 0 282 1T182 2Q120 2 87 2T51 1Q33 1 33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM645 554Q645 567 643 575T634 597T609 619T560 635Q553 636 480 637Q463 637 445 637T416 636T404 636Q391 635 386 627Q384 621 367 550T332 412T314 344Q314 342 395 342H407H430Q542 342 590 392Q617 419 631 471T645 554Z"></path></g><g data-mml-node="mn" transform="translate(675,-150) scale(0.707)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g></g><g data-mml-node="mo" transform="translate(2134.3,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path></g><g data-mml-node="msub" transform="translate(2579,0)"><g data-mml-node="mi"><path data-c="1D443" d="M287 628Q287 635 230 637Q206 637 199 638T192 648Q192 649 194 659Q200 679 203 681T397 683Q587 682 600 680Q664 669 707 631T751 530Q751 453 685 389Q616 321 507 303Q500 302 402 301H307L277 182Q247 66 247 59Q247 55 248 54T255 50T272 48T305 46H336Q342 37 342 35Q342 19 335 5Q330 0 319 0Q316 0 282 1T182 2Q120 2 87 2T51 1Q33 1 33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM645 554Q645 567 643 575T634 597T609 619T560 635Q553 636 480 637Q463 637 445 637T416 636T404 636Q391 635 386 627Q384 621 367 550T332 412T314 344Q314 342 395 342H407H430Q542 342 590 392Q617 419 631 471T645 554Z"></path></g><g data-mml-node="mn" transform="translate(675,-150) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g></g><g data-mml-node="mo" transform="translate(3657.6,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path></g><g data-mml-node="mo" transform="translate(4102.2,0)"><path data-c="2E" d="M78 60Q78 84 95 102T138 120Q162 120 180 104T199 61Q199 36 182 18T139 0T96 17T78 60Z"></path></g><g data-mml-node="mo" transform="translate(4546.9,0)"><path data-c="2E" d="M78 60Q78 84 95 102T138 120Q162 120 180 104T199 61Q199 36 182 18T139 0T96 17T78 60Z"></path></g><g data-mml-node="mo" transform="translate(4991.6,0)"><path data-c="2E" d="M78 60Q78 84 95 102T138 120Q162 120 180 104T199 61Q199 36 182 18T139 0T96 17T78 60Z"></path></g><g data-mml-node="mo" transform="translate(5436.2,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path></g><g data-mml-node="msub" transform="translate(5880.9,0)"><g data-mml-node="mi"><path data-c="1D443" d="M287 628Q287 635 230 637Q206 637 199 638T192 648Q192 649 194 659Q200 679 203 681T397 683Q587 682 600 680Q664 669 707 631T751 530Q751 453 685 389Q616 321 507 303Q500 302 402 301H307L277 182Q247 66 247 59Q247 55 248 54T255 50T272 48T305 46H336Q342 37 342 35Q342 19 335 5Q330 0 319 0Q316 0 282 1T182 2Q120 2 87 2T51 1Q33 1 33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM645 554Q645 567 643 575T634 597T609 619T560 635Q553 636 480 637Q463 637 445 637T416 636T404 636Q391 635 386 627Q384 621 367 550T332 412T314 344Q314 342 395 342H407H430Q542 342 590 392Q617 419 631 471T645 554Z"></path></g><g data-mml-node="mi" transform="translate(675,-150) scale(0.707)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g></g><g data-mml-node="mo" transform="translate(7307.9,0)"><path data-c="3E" d="M84 520Q84 528 88 533T96 539L99 540Q106 540 253 471T544 334L687 265Q694 260 694 250T687 235Q685 233 395 96L107 -40H101Q83 -38 83 -20Q83 -19 83 -17Q82 -10 98 -1Q117 9 248 71Q326 108 378 132L626 250L378 368Q90 504 86 509Q84 513 84 520Z"></path></g></g></g></svg></mjx-container> 来为每个进程分配其所需资源，直到最大需求，使每个进程都可顺序完成。通常称 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.439ex;" xmlns="http://www.w3.org/2000/svg" width="18.294ex" height="1.984ex" role="img" focusable="false" viewBox="0 -683 8085.9 877"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="3C" d="M694 -11T694 -19T688 -33T678 -40Q671 -40 524 29T234 166L90 235Q83 240 83 250Q83 261 91 266Q664 540 678 540Q681 540 687 534T694 519T687 505Q686 504 417 376L151 250L417 124Q686 -4 687 -5Q694 -11 694 -19Z"></path></g><g data-mml-node="msub" transform="translate(1055.8,0)"><g data-mml-node="mi"><path data-c="1D443" d="M287 628Q287 635 230 637Q206 637 199 638T192 648Q192 649 194 659Q200 679 203 681T397 683Q587 682 600 680Q664 669 707 631T751 530Q751 453 685 389Q616 321 507 303Q500 302 402 301H307L277 182Q247 66 247 59Q247 55 248 54T255 50T272 48T305 46H336Q342 37 342 35Q342 19 335 5Q330 0 319 0Q316 0 282 1T182 2Q120 2 87 2T51 1Q33 1 33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM645 554Q645 567 643 575T634 597T609 619T560 635Q553 636 480 637Q463 637 445 637T416 636T404 636Q391 635 386 627Q384 621 367 550T332 412T314 344Q314 342 395 342H407H430Q542 342 590 392Q617 419 631 471T645 554Z"></path></g><g data-mml-node="mn" transform="translate(675,-150) scale(0.707)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g></g><g data-mml-node="mo" transform="translate(2134.3,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path></g><g data-mml-node="msub" transform="translate(2579,0)"><g data-mml-node="mi"><path data-c="1D443" d="M287 628Q287 635 230 637Q206 637 199 638T192 648Q192 649 194 659Q200 679 203 681T397 683Q587 682 600 680Q664 669 707 631T751 530Q751 453 685 389Q616 321 507 303Q500 302 402 301H307L277 182Q247 66 247 59Q247 55 248 54T255 50T272 48T305 46H336Q342 37 342 35Q342 19 335 5Q330 0 319 0Q316 0 282 1T182 2Q120 2 87 2T51 1Q33 1 33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM645 554Q645 567 643 575T634 597T609 619T560 635Q553 636 480 637Q463 637 445 637T416 636T404 636Q391 635 386 627Q384 621 367 550T332 412T314 344Q314 342 395 342H407H430Q542 342 590 392Q617 419 631 471T645 554Z"></path></g><g data-mml-node="mn" transform="translate(675,-150) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g></g><g data-mml-node="mo" transform="translate(3657.6,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path></g><g data-mml-node="mo" transform="translate(4102.2,0)"><path data-c="2E" d="M78 60Q78 84 95 102T138 120Q162 120 180 104T199 61Q199 36 182 18T139 0T96 17T78 60Z"></path></g><g data-mml-node="mo" transform="translate(4546.9,0)"><path data-c="2E" d="M78 60Q78 84 95 102T138 120Q162 120 180 104T199 61Q199 36 182 18T139 0T96 17T78 60Z"></path></g><g data-mml-node="mo" transform="translate(4991.6,0)"><path data-c="2E" d="M78 60Q78 84 95 102T138 120Q162 120 180 104T199 61Q199 36 182 18T139 0T96 17T78 60Z"></path></g><g data-mml-node="mo" transform="translate(5436.2,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path></g><g data-mml-node="msub" transform="translate(5880.9,0)"><g data-mml-node="mi"><path data-c="1D443" d="M287 628Q287 635 230 637Q206 637 199 638T192 648Q192 649 194 659Q200 679 203 681T397 683Q587 682 600 680Q664 669 707 631T751 530Q751 453 685 389Q616 321 507 303Q500 302 402 301H307L277 182Q247 66 247 59Q247 55 248 54T255 50T272 48T305 46H336Q342 37 342 35Q342 19 335 5Q330 0 319 0Q316 0 282 1T182 2Q120 2 87 2T51 1Q33 1 33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM645 554Q645 567 643 575T634 597T609 619T560 635Q553 636 480 637Q463 637 445 637T416 636T404 636Q391 635 386 627Q384 621 367 550T332 412T314 344Q314 342 395 342H407H430Q542 342 590 392Q617 419 631 471T645 554Z"></path></g><g data-mml-node="mi" transform="translate(675,-150) scale(0.707)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g></g><g data-mml-node="mo" transform="translate(7307.9,0)"><path data-c="3E" d="M84 520Q84 528 88 533T96 539L99 540Q106 540 253 471T544 334L687 265Q694 260 694 250T687 235Q685 233 395 96L107 -40H101Q83 -38 83 -20Q83 -19 83 -17Q82 -10 98 -1Q117 9 248 71Q326 108 378 132L626 250L378 368Q90 504 86 509Q84 513 84 520Z"></path></g></g></g></svg></mjx-container> 序列为安全序列。若系统不存在这样一个安全序列，则称系统处于不安全状态。</p><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>传统的进程有两个基本属性：可拥有资源的独立单位；可独立调度和分配的基本单位。引入线程的原因是进程在创建、撤销和切换中，系统必须为之付出较大的时空开销，故在系统中设置的进程数目不宜过多，进程切换的频率不宜太高，这就限制了并发程度的提高。引入线程后，将传统进程的两个基本属性分开，线程作为调度和分配的基本单位，进程作为独立分配资源的单位。用户可以通过创建线程来完成任务，以减少程序并发执行时付出的时空开销。</p><p>例如，在文件服务进程中可设置多个服务线程，当一个线程受阻时，第二个线程可以继续运行，当第二个线程受阻时，第三个线程可以继续运行……从而显著地提高了文件系统的服务质量及系统的吞吐量。</p><p>这样，对于拥有资源的基本单位，不用频繁地切换，进一步提高了系统中各程序的并发程度。需要说明的是，线程是进程中的一个实体，是被系统独立分配和调度的基本单位。线程基本上不拥有资源，只拥有一点运行中必不可少的资源（如程序计数器、一组寄存器和栈），它可与同属一个进程的其他线程共享进程所拥有的全部资源。</p><h2 id="存储管理"><a href="#存储管理" class="headerlink" title="存储管理"></a>存储管理</h2><h3 id="局部性原理"><a href="#局部性原理" class="headerlink" title="局部性原理"></a>局部性原理</h3><p>程序的局限性表现在时间局限性和空间局限性两个方面。</p><p>时间局限性是指如果程序中的某条指令一旦执行，则不久的将来该指令可能再次被执行；如果某个存储单元被访问，则不久以后该存储单元可能再次被访问。产生时间局限性的典型原因是在程序中存在着大量的循环操作。</p><p>空间局限性是指一旦程序访问了某个存储单元，则在不久的将来，其附近的存储单元也最有可能被访问。即程序在一段时间内所访问的地址可能集中在一定的范围内，其典型原因为程序是顺序执行的。</p><h2 id="设备管理"><a href="#设备管理" class="headerlink" title="设备管理"></a>设备管理</h2><h3 id="磁盘调度算法"><a href="#磁盘调度算法" class="headerlink" title="磁盘调度算法"></a>磁盘调度算法</h3><p>常用的磁盘调度算法如下：</p><ol><li><p>先来先服务（FCFS）</p><p> 按请求访问者的先后次序启动磁盘驱动器，而不考虑它们要访问的物理位置。</p></li><li><p>最短寻道时间优先（SSTF）</p><p> 让离当前磁道最近的请求访问者启动磁盘驱动器，即让查找时间最短的那个作业先执行，而不考虑请求访问者到来的先后次序，这样就克服了先来先服务调度算法中磁头移动过大的问题。</p></li><li><p>扫描算法（SCAN）或电梯调度算法</p><p> 总是从磁头当前位置开始，沿磁头的移动方向去选择离当前磁头最近的那个柱面的请求。如果沿磁头的方向无请求访问时，就改变磁头的移动方向。在这种调度方法下磁头的移动类似于电梯的调度，所以它也称为电梯调度算法。</p></li><li><p>单向扫描调度算法（CSCAN）或循环扫描算法</p><p> 循环扫描调度算法是在扫描算法的基础上改进的。为了减少延迟，规定磁头单向移动，例如，只是自里向外移动，从当前位置开始沿磁头的移动方向去选择离当前磁头最近的那个柱面访问，如果沿磁头的方向无请求访问时，磁头立即返回到最里面的欲访问的柱面，再亦即将最小柱面号紧接着最大柱面号构成循环，进行循环扫描。</p></li></ol><h2 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h2><h3 id="文件目录"><a href="#文件目录" class="headerlink" title="文件目录"></a>文件目录</h3><p>为了实现“按名存取”，系统必须为每个文件设置用于描述和控制文件的数据结构，它至少要包括文件名和存放文件的物理地址，这个数据结构称为文件控制块（FCB），文件控制块的有序集合称为文件目录。换句话说，文件目录是由文件控制块组成的，专门用于文件的检索。文件控制块也称为文件的说明或文件目录项（简称目录项）。</p><h4 id="文件控制块"><a href="#文件控制块" class="headerlink" title="文件控制块"></a>文件控制块</h4><p>文件控制块中包含以下三类信息：基本信息类、存取控制信息类和使用信息类。</p><ul><li>基本信息类：例如文件名、文件的物理地址、文件长度和文件块数等。</li><li>存取控制信息类：文件的存取权限，像 UNIX 用户分成文件主、同组用户和般用户三类，这三类用户的读/写执行 RWX 权限。</li><li>使用信息类：文件建立日期、最后一次修改日期、最后一次访问的日期、当前使用的信息（如打开文件的进程数、在文件上的等待队列）等。</li></ul><h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h3><p>文件目录结构的组织方式直接影响到文件的存取速度，关系到文件的共享性和安全性，因此组织好文件的目录是设计文件系统的重要环节。常见的目录结构有 3 种：一级目录结构、二级目录结构和多级目录结构。</p><h4 id="多级目录结构"><a href="#多级目录结构" class="headerlink" title="多级目录结构"></a>多级目录结构</h4><p>为了解决以上问题，在多道程序设计系统中常采用多级目录结构，这种目录结构像一棵倒置的有根树，所以也称为树型目录结构。从树根向下，每一个结点是一个目录，叶结点是文件。MS-DOS 和 UNIX 等操作系统均采用多级目录结构。</p><p>在采用多级目录结构的文件系统中，用户要访问一个文件，必须指出文件所在的路径名，路径名是从根目录开始到该文件的通路上所有各级目录名拼起来得到的。在各目录名之间、目录名与文件名之间需要用分隔符隔开。例如，在 MS-DOS 中分隔符为“\”，在 UNIX 中分隔符为“/”。</p><p>绝对路径名（Absolute Path Name）是指从根目录“/”开始的完整文件名，即它是由从根目录开始的所有目录名以及文件名构成的。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;计算机系统由硬件和软件两部分组成。通常把未配置软件的计算机称为裸机。直接使用裸机不仅不方便，而且将严重降低工作效率和机器的利用率。操作系统（Operating System）目的是为了填补人与机器之间的鸿沟，即建立用户与计算机之间的接口，而为裸机配置的一种系统软件。&lt;/p&gt;</summary>
    
    
    
    <category term="证书考试" scheme="https://lisir.me/hexo-theme-keep/categories/%E8%AF%81%E4%B9%A6%E8%80%83%E8%AF%95/"/>
    
    
    <category term="软考" scheme="https://lisir.me/hexo-theme-keep/tags/%E8%BD%AF%E8%80%83/"/>
    
    <category term="软件设计师" scheme="https://lisir.me/hexo-theme-keep/tags/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/"/>
    
    <category term="操作系统" scheme="https://lisir.me/hexo-theme-keep/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>Java | 泛型</title>
    <link href="https://lisir.me/hexo-theme-keep/posts/62ea5aff/"/>
    <id>https://lisir.me/hexo-theme-keep/posts/62ea5aff/</id>
    <published>2023-05-05T12:09:02.000Z</published>
    <updated>2024-09-02T06:10:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>泛型在 Java 中有很重要的地位，在面向对象编程及各种设计模式中有非常广泛的应用。</p><span id="more"></span><hr><h2 id="泛型说明"><a href="#泛型说明" class="headerlink" title="泛型说明"></a>泛型说明</h2><p>泛型是一种“代码模板”，可以用一套代码套用各种类型。</p><p><img                         lazyload                       alt="image"                       data-src="https://img.lisir.me/image/posts/62ea5aff/20230506125434.png"                        alt="20230506125434"                 ></p><p><strong>泛型的作用：</strong></p><ul><li>泛型其实就是将类型参数化，从而提高参数类型的表达能力。</li><li>泛型可以使用在类、接口和方法上，分别被称为泛型类、泛型接口和泛型方法。</li><li>泛型可以在类声明时通过一个标识符表示类中某个属性的类型，或者是某个方法的返回值的类型，或者是参数类型。</li></ul><p><strong>使用泛型的优势有：</strong></p><ul><li>泛型可以使得程序在编译期间就发现类型匹配问题，而不是在运行期间发现问题。</li><li>泛型可以明确特定对象实例化时的类型信息，避免不必要的类型转换。</li><li>泛型可以提高代码重用性。</li></ul><h2 id="泛型语法"><a href="#泛型语法" class="headerlink" title="泛型语法"></a>泛型语法</h2><p>泛型的标识是在一对尖括号“&lt;&gt;”中包含类型形参，其中的类型形参可以有一个或多个，如：<code>&lt;T&gt;</code>、<code>&lt;T, U&gt;</code>、<code>&lt;K, V&gt;</code>。从语法上来说，类型形参可以是任意字符。但是从开发规范的角度来讲，一般都是采用简短的大写字母来表示：</p><ul><li>用 <code>E</code> 表示集合元素；</li><li><code>K</code> 和 <code>V</code> 分别表示键和值；</li><li><code>T</code> 可以表示任意类型，如果有多个任意类型时，可以使用和 <code>T</code> 相邻的字母，如：<code>U</code>、<code>S</code>。</li></ul><p><strong>使用细节：</strong></p><ul><li>泛型的类型实参只能使用引用类型，不能使用基本数据类型。</li><li>在指定泛型的类型实参后，可以传入该类型或其子类型。</li><li>泛型没有继承性。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误示范</span></span><br><span class="line"><span class="comment">// ArrayList&lt;int&gt; list = new ArrayList&lt;&gt;();</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误示范</span></span><br><span class="line"><span class="comment">// ArrayList&lt;Object&gt; arrayList = new ArrayList&lt;String&gt;();</span></span><br></pre></td></tr></table></figure><h3 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h3><p><strong>使用细节：</strong></p><ul><li>泛型类的类型形参是在创建对象时确定的。</li><li>泛型类中可以定义泛型的数组但不能初始化。</li><li>普通成员（属性、方法）可以使用泛型变量。</li><li>静态成员（属性、方法）不能使用类中的泛型变量，因为静态成员在类加载时还无法获得泛型变量的类型。</li><li>如果泛型类被继承或者被实例化时，没有指定类型实参，则默认为 Object 类。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&lt;K, V&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> K key;</span><br><span class="line">    <span class="keyword">private</span> V value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Test</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.key = key;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> K <span class="title function_">getKey</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setKey</span><span class="params">(K key)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.key = key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> V <span class="title function_">getValue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setValue</span><span class="params">(V value)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h3><p><strong>使用细节：</strong></p><ul><li>泛型接口的类型形参是在继承接口和实现接口时确定的。</li><li>静态成员（属性、方法）不能使用接口中的泛型变量。</li><li>如果泛型接口被继承或被实现时，没有指定类型实参，则默认为 Object 类型。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Test</span>&lt;K, V&gt; &#123;</span><br><span class="line"></span><br><span class="line">    V <span class="title function_">get</span><span class="params">(K key)</span>;</span><br><span class="line"></span><br><span class="line">    V <span class="title function_">put</span><span class="params">(K key, V value)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h3><p><strong>使用细节：</strong></p><ul><li>泛型方法的类型形参在被调用时确定。</li><li>泛型方法既可以定义在普通类中也可以定义在泛型类中。</li><li>泛型方法的形参列表既可以使用类声明的泛型也可以使用自己声明的泛型。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        getObject(<span class="string">&quot;abc&quot;</span>, <span class="number">123</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;K, V&gt; <span class="keyword">void</span> <span class="title function_">getObject</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">        System.out.println(key.getClass());</span><br><span class="line">        System.out.println(value.getClass());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="泛型的通配符"><a href="#泛型的通配符" class="headerlink" title="泛型的通配符"></a>泛型的通配符</h2><p>泛型的表达能力是非常强的，在某些场景下，如果需要限定一个类型范围，而不是某个具体类型的时候，就需要使用类型限定符或类型通配符。</p><p><strong>类型限定符可以归结为下面几种类型：</strong></p><ul><li><p><code>&lt;?&gt;</code>，表示无限制通配符。</p></li><li><p><code>&lt;? extends Type&gt;</code>，表示限定的类型只能是 <code>Type</code> 本身或它的子类，限定了泛型的上限。</p></li><li><p><code>&lt;? super Type&gt;</code>，表示限定的类型只能是 <code>Type</code> 本身或它的父类，限定了泛型的下限。</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;泛型在 Java 中有很重要的地位，在面向对象编程及各种设计模式中有非常广泛的应用。&lt;/p&gt;</summary>
    
    
    
    <category term="学习笔记" scheme="https://lisir.me/hexo-theme-keep/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Java" scheme="https://lisir.me/hexo-theme-keep/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java | 集合框架</title>
    <link href="https://lisir.me/hexo-theme-keep/posts/c7f47f99/"/>
    <id>https://lisir.me/hexo-theme-keep/posts/c7f47f99/</id>
    <published>2023-05-01T12:58:08.000Z</published>
    <updated>2024-09-02T06:10:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>集合就是由若干个确定的元素所构成的整体。</p><span id="more"></span><hr><h2 id="集合体系图"><a href="#集合体系图" class="headerlink" title="集合体系图"></a>集合体系图</h2><p><strong>List、Set 集合体系图：</strong></p><p><img                         lazyload                       alt="image"                       data-src="https://img.lisir.me/image/posts/c7f47f99/20230502084835.png"                        alt="20230502084835"                 ></p><p><strong>Map 集合体系图：</strong></p><p><img                         lazyload                       alt="image"                       data-src="https://img.lisir.me/image/posts/c7f47f99/20230504113740.png"                        alt="20230504113740"                 ></p><h2 id="单列集合"><a href="#单列集合" class="headerlink" title="单列集合"></a>单列集合</h2><h3 id="Iterator-接口"><a href="#Iterator-接口" class="headerlink" title="Iterator 接口"></a>Iterator 接口</h3><p>迭代器（Iterator）主要用来操作 Java 中的集合对象（Collection），迭代器提供了统一的语法进行集合对象遍历操作，无需关心集合对象内部的实现方式，迭代器只能向前移，无法后退。</p><p><strong>Iterator 接口的特点：</strong></p><ul><li><p>Iterator 接口的对象称为迭代器，主要用于遍历 Collection 集合中的元素。</p></li><li><p>Iterator 接口的对象仅用于遍历集合，它本身并不存放对象。</p></li></ul><p><strong>Iterator 接口的方法：</strong></p><table><thead><tr><th>方法名称</th><th>描述</th></tr></thead><tbody><tr><td><code>hasNext()</code></td><td>判断是否还有下一个元素</td></tr><tr><td><code>next()</code></td><td>返回下一个元素</td></tr></tbody></table><blockquote><p>注意：在调用 <code>next()</code> 方法之前必须要调用 <code>hasNext()</code> 进行检测。若不进行检测，且下一条记录无效，直接调用 <code>next()</code> 会抛出 NoSuchElementException 异常。</p></blockquote><h3 id="Collection-接口"><a href="#Collection-接口" class="headerlink" title="Collection 接口"></a>Collection 接口</h3><p>Collection 接口是 List、Set 和 Queue 接口的父接口，通常情况下不被直接使用。Collection 接口定义了一些通用的方法，通过这些方法可以实现对集合的基本操作。定义的方法既可用于操作 Set 集合，也可用于操作 List 和 Queue 集合。</p><p><strong>Collection 接口的特点：</strong></p><ul><li><p>Collection 的实现类可以存放多个元素，每个元素可以是 Object。</p></li><li><p>Collection 的实现类，有些可以存放重复的元素，有些不可以。</p></li><li><p>Collection 的实现类，有些是有序的（List），有些是无序的（Set）。</p></li><li><p>Collection 接口没有直接的实现子类，是通过它的子接口 List 和 Set 来实现的。</p></li><li><p>所有实现了 Collection 接口的集合类都有一个 <code>iterator()</code> 方法，用于返回一个迭代器。</p></li></ul><p><strong>Collection 接口的方法：</strong></p><table><thead><tr><th>方法名称</th><th>描述</th></tr></thead><tbody><tr><td><code>add()</code></td><td>添加单个元素</td></tr><tr><td><code>addAll()</code></td><td>添加多个元素</td></tr><tr><td><code>remove()</code></td><td>删除指定元素</td></tr><tr><td><code>removeAll()</code></td><td>删除多个元素</td></tr><tr><td><code>contains()</code></td><td>查找元素是否存在</td></tr><tr><td><code>containsAll()</code></td><td>查找多个元素是否都存在</td></tr><tr><td><code>size()</code></td><td>获取元素个数</td></tr><tr><td><code>isEmpty()</code></td><td>判断是否为空</td></tr><tr><td><code>clear()</code></td><td>清除所有元素</td></tr></tbody></table><h3 id="List-接口"><a href="#List-接口" class="headerlink" title="List 接口"></a>List 接口</h3><p>List 是一个有序、可重复的集合，集合中每个元素都有其对应的顺序索引。</p><p><strong>List 接口的特点：</strong></p><ul><li><p>List 接口是 Collection 接口的子接口。</p></li><li><p>List 集合中的元素有序（添加顺序和取出顺序一致）、且可重复。</p></li><li><p>List 集合中的每个元素都有其对应的顺序索引（从 0 开始），即支持索引。</p></li><li><p>List 集合中的元素都对应一个整数型的序号记载元素在集合中的位置，可以根据序号存取集合中的元素。</p></li></ul><p><strong>List 接口的方法：</strong></p><table><thead><tr><th>方法名称</th><th>描述</th></tr></thead><tbody><tr><td><code>get()</code></td><td>获取此集合中指定索引位置的元素</td></tr><tr><td><code>set()</code></td><td>替换此集合中指定索引位置的元素</td></tr><tr><td><code>indexOf()</code></td><td>返回此集合中第一次出现指定元素的索引，如果此集合不包含该元素，则返回 -1</td></tr><tr><td><code>lastIndexOf()</code></td><td>返回此集合中最后一次出现指定元素的索引，如果此集合不包含该元素，则返回 -1</td></tr><tr><td><code>subList()</code></td><td>截取集合中的一部分形成一个新的集合并返回</td></tr></tbody></table><p><strong>List 接口的遍历方式：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 以 ArrayList 类为例，其他 List 接口的实现类同理</span></span><br><span class="line">        <span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line"></span><br><span class="line">        list.add(<span class="keyword">new</span> <span class="title class_">Book</span>(<span class="string">&quot;三国演义&quot;</span>, <span class="string">&quot;罗贯中&quot;</span>, <span class="number">10.1</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> <span class="title class_">Book</span>(<span class="string">&quot;小李飞刀&quot;</span>, <span class="string">&quot;古龙&quot;</span>, <span class="number">5.1</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> <span class="title class_">Book</span>(<span class="string">&quot;红楼梦&quot;</span>, <span class="string">&quot;曹雪芹&quot;</span>, <span class="number">34.6</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 方式一：使用迭代器</span></span><br><span class="line">        System.out.println(<span class="string">&quot;========== 第一种方式 ==========&quot;</span>);</span><br><span class="line">        <span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> list.iterator(); <span class="comment">// 获取 arrayList 的迭代器</span></span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">book</span> <span class="operator">=</span> iterator.next(); <span class="comment">// 返回下一个元素，使用 Object 类接收</span></span><br><span class="line">            System.out.println(book);</span><br><span class="line">        &#125;</span><br><span class="line">        iterator = list.iterator(); <span class="comment">// 重置迭代器</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 方式二：使用增强 for 循环遍历集合，其底层任然是迭代器</span></span><br><span class="line">        System.out.println(<span class="string">&quot;========== 第二种方式 ==========&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Object book : list) &#123;</span><br><span class="line">            System.out.println(book);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 方式三：使用普通 for 循环</span></span><br><span class="line">        System.out.println(<span class="string">&quot;========== 第三种方式 ==========&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">            System.out.println(list.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Book</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String author;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> price;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Book</span><span class="params">(String name, String author, <span class="type">double</span> price)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.author = author;</span><br><span class="line">        <span class="built_in">this</span>.price = price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getAuthor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> author;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAuthor</span><span class="params">(String author)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.author = author;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getPrice</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPrice</span><span class="params">(<span class="type">double</span> price)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.price = price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Book&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, author=&#x27;&quot;</span> + author + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, price=&quot;</span> + price +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ArrayList-类"><a href="#ArrayList-类" class="headerlink" title="ArrayList 类"></a>ArrayList 类</h4><p><strong>ArrayList 和 Vector 类的特点：</strong></p><ul><li><p>两者几乎是一样的，区别在于 Vector 类是线程安全的，因此效率差于 ArrayList 类。</p></li><li><p>底层都是使用 Object 类型的数组 <code>elementData</code> 来存储元素。</p></li><li><p>底层都实现了可变长数组，可以添加任意元素且可以重复，包括 <code>null</code> 值。</p></li></ul><p><strong>ArrayList 和 Vector 类的扩容机制：</strong></p><ul><li><p>如果使用无参构造器创建对象时，初始 <code>elementData</code> 容量为 0，第一次添加元素则扩容 <code>elementData</code> 为 10。</p></li><li><p>如需再次扩容，ArrayList 类扩容为原来大小的 1.5 倍，Vector 类则是扩容为原来的 2 倍。</p></li><li><p>如果使用的是指定大小的构造器，则初始 <code>elementData</code> 容量为指定大小，扩容机制不变。</p></li></ul><h4 id="LinkedList-类"><a href="#LinkedList-类" class="headerlink" title="LinkedList 类"></a>LinkedList 类</h4><p><strong>LinkedList 类的特点：</strong></p><ul><li><p>LinkedList 类是线程不安全的。</p></li><li><p>底层使用 Node（静态内部类）类型的结点来存储元素。</p></li><li><p>底层有两个属性 <code>first</code> 和 <code>last</code> 分别指向头结点和尾结点。</p></li><li><p>每个结点中又有三属性，<code>prev</code> 指向直接前驱结点，<code>next</code> 指向直接后继结点，<code>item</code> 存储真正的元素。</p></li><li><p>底层实现了双向链表和双端队列，可以添加任意元素且可以重复，包括 <code>null</code> 值。</p></li><li><p>底层采用双向链表的结构保存元素，这种结构的优点是便于向集合中插入或者删除元素。</p></li></ul><h4 id="两者的区别"><a href="#两者的区别" class="headerlink" title="两者的区别"></a>两者的区别</h4><p><strong>ArrayList 和 LinkedList 类的区别：</strong></p><ul><li><p>需要频繁修改和查询元素时，使用 ArrayList 类。</p></li><li><p>需要频繁插入和删除元素时，使用 LinkedList 类。</p></li><li><p>ArrayList 是底层基于可变长数组，增删效率较低（扩容需要大量拷贝），改查效率较高（通过索引直接定位）。</p></li><li><p>LinkedList 是底层基于双向链表，增删效率较高（元素通过指针连接），改查效率较低（查询需要依次遍历）。</p></li><li><p>ArrayList 与 LinkedList 都是 List 接口的实现类，因此都实现了 List 的所有未实现的方法，只是实现的方式有所不同。</p></li></ul><h3 id="Set-接口"><a href="#Set-接口" class="headerlink" title="Set 接口"></a>Set 接口</h3><p>Set 是一个无序、不可重复的集合，且没有索引。</p><p><strong>Set 接口的特点：</strong></p><ul><li><p>Set 接口是 Collection 接口的子接口。</p></li><li><p>Set 集合中的元素无序（添加顺序和取出顺序不一致，但是取出顺序是固定的），且不可重复。</p></li><li><p>Set 集合中的元素不按特定的方式排序，只是简单地把元素加入集合。</p></li><li><p>Set 集合中不能包含重复的元素，并且只允许包含一个 <code>null</code> 值。</p></li></ul><p><strong>Set 接口的方法：</strong></p><p>和 List 接口一样，Set 接口也是 Collection 的子接口，因此常用方法和 Collection 接口一样。</p><p><strong>Set 接口的遍历方式：</strong></p><p>和 Collection 的遍历方式一样，可以使用迭代器和增强 <code>for</code> 循环，但不能使用索引的方式来获取。</p><h4 id="HashSet-类"><a href="#HashSet-类" class="headerlink" title="HashSet 类"></a>HashSet 类</h4><p><strong>HashSet 类的特点：</strong></p><ul><li><p>HashSet 类是线程不安全的。</p></li><li><p>底层使用 Node（静态内部类）类型的结点数组 <code>table</code> 来存储元素。</p></li><li><p>底层实际上是 HashMap 类，是由数组和链表以及红黑树构成的。</p></li><li><p>HashSet 类是按照 Hash 算法来存储集合中的元素，因此具有很好的存取和查找性能。</p></li></ul><p><strong>HashSet 类添加元素的底层机制：</strong></p><ol><li><p>添加元素时会先计算哈希值，再将哈希值转换为索引值。</p></li><li><p>找到 <code>table</code> 数组，查看该索引的位置是否有元素。</p></li><li><p>如果没有则直接加入元素。如果有，则比较两个元素是否相同。</p></li><li><p>相同就放弃添加，不相同就以链表的方式添加到尾部，形成数组加链表的模式。</p><blockquote><p>注意：比较两个元素是否相同是通过 <code>equals()</code> 方法和 <code>hashCode()</code> 方法的返回值来一同决定的；<code>equals()</code> 方法和 <code>hashCode()</code> 方法可以重写来修改比较的标准；只有在哈希值相同的情况下才会使用 <code>equals()</code> 方法进行比较。</p></blockquote></li></ol><p><strong>HashSet 类扩容和转成红黑树的底层机制：</strong></p><ol><li><p>第一次添加元素时，<code>table</code> 数组扩容到 16，且临界值设为 <code>16 * 0.75 = 12</code>（<code>0.75</code> 是加载因子）。</p></li><li><p>当集合中的元素个数达到临界值 12 时，<code>table</code> 数组就会扩容到 <code>16 * 2 = 32</code>。</p></li><li><p>新的临界值就是 <code>32 * 0.75 = 24</code>，以此类推。</p><blockquote><p>注意：这里的扩容机制判断的是整个集合中的元素个数，并非一定是 <code>table</code> 数组中的元素个数。</p></blockquote></li><li><p>如果单条链表中元素达到 8，同时 <code>table</code> 数组的大小达到 64 时，就会进行树化（红黑树），若 <code>table</code> 数组大小未达到 64，则采用数组扩容机制进行扩容，直到 <code>table</code> 数组大小达到 64，再树化。</p><blockquote><p>注意：这里的扩容机制主要是为了防止单条链表上的元素过多，所以会进行扩容，加快树化的进度。</p></blockquote></li></ol><h4 id="LinkedHashSet-类"><a href="#LinkedHashSet-类" class="headerlink" title="LinkedHashSet 类"></a>LinkedHashSet 类</h4><p><strong>LinkedHashSet 类的特点：</strong></p><ul><li><p>LinkedHashSet 类继承了 HashSet 类。</p></li><li><p>底层实际上是 LinkedHashMap 类，是由数组和双向链表构成的。</p></li><li><p>底层使用 Entry（静态内部类）类型的结点来存储元素。</p></li><li><p>每个结点中有 <code>before</code> 和 <code>after</code> 属性，<code>before</code> 指向直接前驱结点，<code>after</code> 指向直接后继结点。</p></li><li><p>底层是根据元素的哈希值决定元素的存储位置，同时使用双向链表维护元素的次序，这使得元素看起来是以插入顺序保存的。</p></li></ul><p><strong>LinkedHashSet 类添加元素的底层机制：</strong></p><ol><li><p>LinkedHashSet 类和 HashSet 类的机制大同小异。</p></li><li><p>LinkedHashSet 类在添加元素时不仅会执行 HashSet 类同样的操作，同时还会将元素加入到双向链表。</p></li></ol><h2 id="双列集合"><a href="#双列集合" class="headerlink" title="双列集合"></a>双列集合</h2><h3 id="Map-接口"><a href="#Map-接口" class="headerlink" title="Map 接口"></a>Map 接口</h3><p>Map 是一种键值对（key-value）集合，Map 集合中的每一个元素都包含一个键（key）对象和一个值（value）对象。用于保存具有映射关系的数据。</p><p><strong>Map 接口的特点：</strong></p><ul><li><p>Map 集合中的 key 和 value 可以是任何引用类型的数据，会封装到 HashMap 类中的 Node 静态内部类对象中。</p></li><li><p>Map 集合中的 key 不允许重复，但 value 可以重复；key 可以有一个为 <code>null</code> 值，value 可以多个为 <code>null</code> 值。</p></li><li><p>Map 集合中的 key 和 value 之间存在单向一对一关系，即通过指定的 key 总能找到对应的 value。</p></li></ul><p><strong>Map 接口的方法：</strong></p><table><thead><tr><th>方法名称</th><th>描述</th></tr></thead><tbody><tr><td><code>put()</code></td><td>添加键值对</td></tr><tr><td><code>remove()</code></td><td>根据键删除映射关系</td></tr><tr><td><code>get()</code></td><td>根据键获取值</td></tr><tr><td><code>size()</code></td><td>获取键值对个数</td></tr><tr><td><code>isEmpty()</code></td><td>判断键值对个数是否为 0</td></tr><tr><td><code>containsKey()</code></td><td>查找键是否存在</td></tr><tr><td><code>clear()</code></td><td>清除所有键值对</td></tr><tr><td><code>keySet()</code></td><td>获取所有的键</td></tr><tr><td><code>values()</code></td><td>获取所有的值</td></tr><tr><td><code>entrySet()</code></td><td>获取所有的键值对</td></tr></tbody></table><p><strong>Map 接口的遍历方式：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line"></span><br><span class="line">        map.put(<span class="string">&quot;No.1&quot;</span>, <span class="string">&quot;张浩太&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;No.2&quot;</span>, <span class="string">&quot;刘思诚&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;No.3&quot;</span>, <span class="string">&quot;王强文&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;No.4&quot;</span>, <span class="string">&quot;李国量&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;No.5&quot;</span>, <span class="string">&quot;王路路&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第一组：先取出所有的 key，通过 key 取出对应的 value</span></span><br><span class="line">        <span class="type">Set</span> <span class="variable">keySet</span> <span class="operator">=</span> map.keySet();</span><br><span class="line">        <span class="comment">// 使用增强 for 循环</span></span><br><span class="line">        System.out.println(<span class="string">&quot;========== 第一种方式 ==========&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Object key : keySet) &#123;</span><br><span class="line">            System.out.println(key + <span class="string">&quot;:&quot;</span> + map.get(key));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 使用迭代器</span></span><br><span class="line">        System.out.println(<span class="string">&quot;========== 第二种方式 ==========&quot;</span>);</span><br><span class="line">        <span class="type">Iterator</span> <span class="variable">iterator1</span> <span class="operator">=</span> keySet.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator1.hasNext()) &#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">key</span> <span class="operator">=</span> iterator1.next();</span><br><span class="line">            System.out.println(key + <span class="string">&quot;:&quot;</span> + map.get(key));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第二组：直接取出所有的 value</span></span><br><span class="line">        <span class="type">Collection</span> <span class="variable">values</span> <span class="operator">=</span> map.values();</span><br><span class="line">        <span class="comment">// 使用增强 for 循环</span></span><br><span class="line">        System.out.println(<span class="string">&quot;========== 第三种方式 ==========&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Object value : values) &#123;</span><br><span class="line">            System.out.println(value);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 使用迭代器</span></span><br><span class="line">        System.out.println(<span class="string">&quot;========== 第四种方式 ==========&quot;</span>);</span><br><span class="line">        <span class="type">Iterator</span> <span class="variable">iterator2</span> <span class="operator">=</span> values.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator2.hasNext()) &#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> iterator2.next();</span><br><span class="line">            System.out.println(value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第三组：通过 entrySet() 方法获取键值对</span></span><br><span class="line">        <span class="type">Set</span> <span class="variable">entrySet</span> <span class="operator">=</span> map.entrySet();</span><br><span class="line">        <span class="comment">// 使用增强 for 循环</span></span><br><span class="line">        System.out.println(<span class="string">&quot;========== 第五种方式 ==========&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Object entry : entrySet) &#123;</span><br><span class="line">            Map.<span class="type">Entry</span> <span class="variable">m</span> <span class="operator">=</span> (Map.Entry) entry;</span><br><span class="line">            System.out.println(m.getKey() + <span class="string">&quot;:&quot;</span> + m.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 使用迭代器</span></span><br><span class="line">        System.out.println(<span class="string">&quot;========== 第六种方式 ==========&quot;</span>);</span><br><span class="line">        <span class="type">Iterator</span> <span class="variable">iterator3</span> <span class="operator">=</span> entrySet.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator3.hasNext()) &#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">entry</span> <span class="operator">=</span> iterator3.next();</span><br><span class="line">            Map.<span class="type">Entry</span> <span class="variable">m</span> <span class="operator">=</span> (Map.Entry) entry;</span><br><span class="line">            System.out.println(m.getKey() + <span class="string">&quot;:&quot;</span> + m.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="HashMap-类"><a href="#HashMap-类" class="headerlink" title="HashMap 类"></a>HashMap 类</h4><p><strong>HashMap 类的特点：</strong></p><ul><li><p>HashMap 类是线程不安全的。</p></li><li><p>底层使用 Node（静态内部类）类型的结点数组 <code>table</code> 来存储元素。</p></li><li><p>每个结点中又有四个属性，<code>key</code> 存放键，<code>value</code> 存放值，<code>hash</code> 存放键的哈希值，<code>next</code> 存放直接后继结点。</p></li></ul><p><strong>HashMap 类添加元素的底层机制：</strong></p><ol><li><p>添加元素时，通过 <code>key</code> 的哈希值得到在 <code>table</code> 数组的索引。</p></li><li><p>判断该索引处是否有元素，如果没有则直接添加。</p></li><li><p>如果该索引处有元素，则判断该元素的 <code>key</code> 是否和准备加入的元素的 <code>key</code> 相等。</p></li><li><p>如果相等，则直接替换 <code>value</code>，如果不相等，则需要判断是树结构还是链表结构，做出相应的处理。</p></li><li><p>如果添加时发现容量不够，则需要扩容。HashMap 类的扩容和转成红黑树的底层机制和 HashSet 类相同。</p></li></ol><h4 id="Hashtable-类"><a href="#Hashtable-类" class="headerlink" title="Hashtable 类"></a>Hashtable 类</h4><p><strong>Hashtable 类的特点：</strong></p><ul><li><p>Hashtable 类是线程安全的。</p></li><li><p>底层使用 Entry（静态内部类）类型的结点数组 <code>table</code> 来存储元素。</p></li><li><p>Hashtable 类的使用方法基本上和 HashMap 类一样。</p></li><li><p>Hashtable 类的键和值都不能为 <code>null</code>，否则会抛出 NullPointerException 异常。</p></li></ul><p><strong>Hashtable 类扩容的底层机制：</strong></p><ol><li><p>首次添加元素时，初始化 <code>table</code> 数组为 11。</p></li><li><p>临界值为 <code>table</code> 数组的大小乘以 0.75。</p></li><li><p>当集合中的元素达到临界值时，则按照原 <code>table</code> 数组大小的两倍再加 1 进行扩容。</p></li></ol><h4 id="Properties-类"><a href="#Properties-类" class="headerlink" title="Properties 类"></a>Properties 类</h4><p><strong>Properties 类的特点：</strong></p><ul><li><p>Properties 类继承了 Hashtable 类。</p></li><li><p>Properties 类的键和值都不能为 <code>null</code>，否则会抛出 NullPointerException 异常。</p></li></ul><h4 id="TreeMap-类"><a href="#TreeMap-类" class="headerlink" title="TreeMap 类"></a>TreeMap 类</h4><p><strong>TreeMap 类的特点：</strong></p><ul><li><p>底层是由二叉树构成，实现了红黑树的结构。</p></li><li><p>TreeMap 类默认会对键进行排序，所以键必须实现自然排序和定制排序中的一种。</p></li></ul><h2 id="集合选型规则"><a href="#集合选型规则" class="headerlink" title="集合选型规则"></a>集合选型规则</h2><p>在开发中，选择什么集合实现类，主要取决于业务操作特点，然后根据集合实现类的特性进行选择。</p><ul><li><p>先判断存储的类型：一组对象（单列）还是一组键值对（双列）。</p></li><li><p>一组对象：Collection 接口</p><ul><li><p>允许重复的：List 接口</p><ul><li>增删操作多：LinkedList 类</li><li>改查操作多：ArrayList 类</li></ul></li><li><p>不允许重复的：Set 接口</p><ul><li>无序的：HashSet 类</li><li>可排序的：TreeSet 类</li><li>插入和取出顺序一致的：LinkedHashSet 类</li></ul></li></ul></li><li><p>一组键值对：Map 接口</p><ul><li>键是无序的：HashMap 类</li><li>键是可排序的：TreeMap 类</li><li>键的插入和取出顺序一致的：LinkedHashMap 类</li><li>可读取文件的：Properties 类</li></ul></li></ul><h2 id="Collections-工具类"><a href="#Collections-工具类" class="headerlink" title="Collections 工具类"></a>Collections 工具类</h2><p>Collections 类是一个操作 Set、List 和 Map 等集合的工具类。Collections 类中提供了一系列静态的方法对集合元素进行排序、查询和修改等操作。</p><p><strong>Collections 工具类的常用方法：</strong></p><table><thead><tr><th>方法名称</th><th>描述</th></tr></thead><tbody><tr><td><code>Collections.reverse()</code></td><td>反转 List 集合中元素的顺序</td></tr><tr><td><code>Collections.shuffle()</code></td><td>对 List 集合中的元素进行随机排序</td></tr><tr><td><code>Collections.sort()</code></td><td>根据元素的自然顺序对指定的 List 集合中的元素按升序排序</td></tr><tr><td><code>Collections.swap()</code></td><td>将指定 List 集合中的两个元素进行交换</td></tr><tr><td><code>Collections.frequency()</code></td><td>返回指定集合中指定元素的出现次数</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;p&gt;集合就是由若干个确定的元素所构成的整体。&lt;/p&gt;</summary>
    
    
    
    <category term="学习笔记" scheme="https://lisir.me/hexo-theme-keep/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Java" scheme="https://lisir.me/hexo-theme-keep/tags/Java/"/>
    
  </entry>
  
</feed>
